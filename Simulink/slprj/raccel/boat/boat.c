#include "boat.h"
#include "rtwtypes.h"
#include "boat_private.h"
#include "mwmathutil.h"
#include <stdlib.h>
#include <stddef.h>
#include "boat_types.h"
#include "rt_logging_mmi.h"
#include "boat_capi.h"
#include "boat_dt.h"
extern void * CreateDiagnosticAsVoidPtr_wrapper ( const char * id , int nargs
, ... ) ; extern ssExecutionInfo gblExecutionInfo ; RTWExtModeInfo *
gblRTWExtModeInfo = NULL ; void raccelForceExtModeShutdown ( boolean_T
extModeStartPktReceived ) { if ( ! extModeStartPktReceived ) { boolean_T
stopRequested = false ; rtExtModeWaitForStartPkt ( gblRTWExtModeInfo , 6 , &
stopRequested ) ; } rtExtModeShutdown ( 6 ) ; }
#include "slsv_diagnostic_codegen_c_api.h"
#include "slsa_engine_exec.h"
#ifdef RSIM_WITH_SOLVER_MULTITASKING
boolean_T gbl_raccel_isMultitasking = 1 ;
#else
boolean_T gbl_raccel_isMultitasking = 0 ;
#endif
boolean_T gbl_raccel_tid01eq = 0 ; int_T gbl_raccel_NumST = 7 ; const char_T
* gbl_raccel_Version = "24.2 (R2024b) 21-Jun-2024" ; void
raccel_setup_MMIStateLog ( SimStruct * S ) {
#ifdef UseMMIDataLogging
rt_FillStateSigInfoFromMMI ( ssGetRTWLogInfo ( S ) , & ssGetErrorStatus ( S )
) ;
#else
UNUSED_PARAMETER ( S ) ;
#endif
} static DataMapInfo rt_dataMapInfo ; DataMapInfo * rt_dataMapInfoPtr = &
rt_dataMapInfo ; rtwCAPI_ModelMappingInfo * rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; int_T enableFcnCallFlag [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; const char * raccelLoadInputsAndAperiodicHitTimes ( SimStruct * S , const char * inportFileName , int * matFileFormat ) { return rt_RAccelReadInportsMatFile ( S , inportFileName , matFileFormat ) ; }
#include "simstruc.h"
#include "fixedpoint.h"
#include "slsa_engine_exec.h"
#include "simtarget/slSimTgtSLExecSimBridge.h"
#define pqdqd2kc2j (-1)
#define l4pidgtk42 (-1)
#define b030p30edj (-1)
B rtB ; X rtX ; DW rtDW ; static SimStruct model_S ; SimStruct * const rtS =
& model_S ; void olmprp1kyz ( dcuqggditr * localDW ) { localDW -> bhv4aykvhq
= false ; localDW -> cxxrtrw5jz = pqdqd2kc2j ; } void psywd01xtt ( real_T
kbxftg04wq , real_T ojconjfhxc , nzammgjvaw * localB , dcuqggditr * localDW )
{ localDW -> cxxrtrw5jz = pqdqd2kc2j ; if ( kbxftg04wq <= 0.0 ) { localB ->
ippecxjt0i = ojconjfhxc ; } else { localB -> ippecxjt0i = - ojconjfhxc ; } }
void d5w2dp15qi ( htzzi0tma2 * localDW ) { localDW -> mbrn4fhlwd = false ;
localDW -> ajgetwghvc = l4pidgtk42 ; } void ldzksap41j ( real_T f5oess2axs ,
real_T pe2znzyees , real_T mjeuj1qedv , ggwgwfq2ob * localB , htzzi0tma2 *
localDW ) { real_T tmp ; real_T tmp_p ; localDW -> ajgetwghvc = l4pidgtk42 ;
tmp = muDoubleScalarCos ( pe2znzyees ) ; tmp_p = muDoubleScalarSin ( pe2znzyees
) ; localB -> b5rb2zovck = - ( ( muDoubleScalarCos ( mjeuj1qedv ) * tmp + -
muDoubleScalarSin ( mjeuj1qedv ) * tmp_p ) * f5oess2axs ) ; localB ->
pxdcpjxbb2 = - ( ( muDoubleScalarSin ( mjeuj1qedv ) * tmp + muDoubleScalarCos
( mjeuj1qedv ) * tmp_p ) * f5oess2axs ) ; } real_T rt_urand_Upu32_Yd_f_pw_snf
( uint32_T * u ) { uint32_T hi ; uint32_T lo ; lo = * u % 127773U * 16807U ;
hi = * u / 127773U * 2836U ; if ( lo < hi ) { * u = 2147483647U - ( hi - lo )
; } else { * u = lo - hi ; } return ( real_T ) * u * 4.6566128752457969E-10 ;
} real_T rt_nrand_Upu32_Yd_f_pw_snf ( uint32_T * u ) { real_T si ; real_T sr
; real_T y ; do { sr = 2.0 * rt_urand_Upu32_Yd_f_pw_snf ( u ) - 1.0 ; si =
2.0 * rt_urand_Upu32_Yd_f_pw_snf ( u ) - 1.0 ; si = sr * sr + si * si ; }
while ( si > 1.0 ) ; y = muDoubleScalarSqrt ( - 2.0 * muDoubleScalarLog ( si
) / si ) * sr ; return y ; } void MdlInitialize ( void ) { real_T tmp ;
int32_T r ; int32_T t ; uint32_T tseed ; rtX . f2d4l4jl4s = rtP .
Integrator1_IC ; rtX . eqm01ekw05 = rtP . Integrator3_IC ; rtX . llcy0vep2l =
rtP . Integrator5_IC ; rtX . kv3akytruj = rtP .
PIDController_InitialConditionForIntegrator ; rtX . ecyoj2i3gw = rtP .
PIDController_InitialConditionForFilter ; rtDW . evor0o0u1w = ssGetTaskTime ( rtS , 1 ) ; rtDW . ozkuq5jrkw = true ; rtDW . n52coetlf4 = true ; rtDW . jj4ax1istk = ssGetTaskTime ( rtS , 1 ) ; rtDW . megpocnlzf = ( rtMinusInf ) ; rtDW . l1c0vzua01 = 0ULL ; rtDW . pozaiatm4a = true ; rtDW . gf4ksr2aha = true ; rtX . g13n4kjtrj = rtP . PIDController1_InitialConditionForIntegrator ; rtX . bgucvxka1s = rtP . PIDController1_InitialConditionForFilter ; rtX . lgrsqc5d1d = rtP . PIDController2_InitialConditionForIntegrator ; rtX . fmj0130ch2 = rtP . PIDController2_InitialConditionForFilter ; rtDW . cq4fy31po1 = ssGetTaskTime ( rtS , 1 ) ; rtDW . fgliutlg4v = true ; rtDW . gbzgjra1qd = true ; rtDW . ifeym0p3d4 = ssGetTaskTime ( rtS , 1 ) ; rtDW . doojhifyms = ( rtMinusInf ) ; rtDW . j1zvgotszs = 0ULL ; rtDW . krmutnbn45 = true ; rtDW . njxj2gqdqb = true ; rtDW . ik3uudsjyg = ssGetTaskTime ( rtS , 1 ) ; rtDW . kdmfiti23w = true ; rtDW . phgeenzoik = true ; rtDW . and0otfyv2 = ssGetTaskTime ( rtS , 1 ) ; rtDW . habwkca01a = ( rtMinusInf ) ; rtDW . oktrhzldpx = 0ULL ; rtDW . myaevvlju4 = true ; rtDW . m405qgdu1y = true ; tmp = muDoubleScalarFloor ( rtP . BandLimitedWhiteNoiseMeasurementnoise_seed ) ; if ( muDoubleScalarIsNaN ( tmp ) || muDoubleScalarIsInf ( tmp ) ) { tmp = 0.0 ; } else { tmp = muDoubleScalarRem ( tmp , 4.294967296E+9 ) ; } if ( tmp < 0.0 ) { tseed = ( uint32_T ) - ( int32_T ) ( uint32_T ) - tmp ; } else { tseed = ( uint32_T ) tmp ; } r = ( int32_T ) ( tseed >> 16U ) ; t = ( int32_T ) ( tseed & 32768U ) ; tseed = ( ( ( ( tseed - ( ( uint32_T ) r << 16U ) ) + ( uint32_T ) t ) << 16U ) + ( uint32_T ) t ) + ( uint32_T ) r ; if ( tseed < 1U ) { tseed = 1144108930U ; } else if ( tseed > 2147483646U ) { tseed = 2147483646U ; } rtDW . lndskdfmom = tseed ; rtDW . k4wpb4vucr = rt_nrand_Upu32_Yd_f_pw_snf ( & rtDW . lndskdfmom ) * rtP . WhiteNoise_StdDev + rtP . WhiteNoise_Mean ; tmp = muDoubleScalarFloor ( rtP . UniformRandomNumber1_Seed ) ; if ( muDoubleScalarIsNaN ( tmp ) || muDoubleScalarIsInf ( tmp ) ) { tmp = 0.0 ; } else { tmp = muDoubleScalarRem ( tmp , 4.294967296E+9 ) ; } if ( tmp < 0.0 ) { tseed = ( uint32_T ) - ( int32_T ) ( uint32_T ) - tmp ; } else { tseed = ( uint32_T ) tmp ; } r = ( int32_T ) ( tseed >> 16U ) ; t = ( int32_T ) ( tseed & 32768U ) ; tseed = ( ( ( ( tseed - ( ( uint32_T ) r << 16U ) ) + ( uint32_T ) t ) << 16U ) + ( uint32_T ) t ) + ( uint32_T ) r ; if ( tseed < 1U ) { tseed = 1144108930U ; } else if ( tseed > 2147483646U ) { tseed = 2147483646U ; } rtDW . iur0xot0u0 = tseed ; rtDW . k1sbpk4k2l = ( rtP . UniformRandomNumber1_Maximum - rtP . UniformRandomNumber1_Minimum ) * rt_urand_Upu32_Yd_f_pw_snf ( & rtDW . iur0xot0u0 ) + rtP . UniformRandomNumber1_Minimum ; rtX . de235fb3n0 = rtP . Integrator4_IC ; rtX . fqzv5kmfjl = rtP . Integrator_IC ; rtX . mofkaqi0xy = rtP . Integrator2_IC ; tmp = muDoubleScalarFloor ( rtP . UniformRandomNumber_Seed ) ; if ( muDoubleScalarIsNaN ( tmp ) || muDoubleScalarIsInf ( tmp ) ) { tmp = 0.0 ; } else { tmp = muDoubleScalarRem ( tmp , 4.294967296E+9 ) ; } if ( tmp < 0.0 ) { tseed = ( uint32_T ) - ( int32_T ) ( uint32_T ) - tmp ; } else { tseed = ( uint32_T ) tmp ; } r = ( int32_T ) ( tseed >> 16U ) ; t = ( int32_T ) ( tseed & 32768U ) ; tseed = ( ( ( ( tseed - ( ( uint32_T ) r << 16U ) ) + ( uint32_T ) t ) << 16U ) + ( uint32_T ) t ) + ( uint32_T ) r ; if ( tseed < 1U ) { tseed = 1144108930U ; } else if ( tseed > 2147483646U ) { tseed = 2147483646U ; } rtDW . hwgvqn3aty = tseed ; rtDW . ewof0menw2 = ( rtP . UniformRandomNumber_Maximum - rtP . UniformRandomNumber_Minimum ) * rt_urand_Upu32_Yd_f_pw_snf ( & rtDW . hwgvqn3aty ) + rtP . UniformRandomNumber_Minimum ; rtX . ds1lkir2ik = rtP . Integrator6_IC ; olmprp1kyz ( & rtDW . hbgiv4wxgq ) ; d5w2dp15qi ( & rtDW . nf1oadke3r ) ; olmprp1kyz ( & rtDW . ifmn2jhohh ) ; d5w2dp15qi ( & rtDW . fmscqp2pk3 ) ; rtDW . ihhztqiixf = false ; rtDW . aqm5jnhwyz = b030p30edj ; } void MdlEnable ( void ) { _ssSetSampleHit ( rtS , 5 , 1 ) ; _ssSetTaskTime ( rtS , 5 , ssGetT ( rtS ) ) ; _ssSetVarNextHitTime ( rtS , 2 , ssGetT ( rtS ) ) ; ; rtDW . ozkuq5jrkw = true ; rtDW . n52coetlf4 = true ; rtDW . jj4ax1istk = ssGetTaskTime ( rtS , 1 ) ; rtDW . megpocnlzf = ( rtMinusInf ) ; rtDW . l1c0vzua01 = 0ULL ; _ssSetSampleHit ( rtS , 3 , 1 ) ; _ssSetTaskTime ( rtS , 3 , ssGetT ( rtS ) ) ; _ssSetVarNextHitTime ( rtS , 0 , ssGetT ( rtS ) ) ; ; rtDW . fgliutlg4v = true ; rtDW . gbzgjra1qd = true ; rtDW . ifeym0p3d4 = ssGetTaskTime ( rtS , 1 ) ; rtDW . doojhifyms = ( rtMinusInf ) ; rtDW . j1zvgotszs = 0ULL ; _ssSetSampleHit ( rtS , 4 , 1 ) ; _ssSetTaskTime ( rtS , 4 , ssGetT ( rtS ) ) ; _ssSetVarNextHitTime ( rtS , 1 , ssGetT ( rtS ) ) ; ; rtDW . kdmfiti23w = true ; rtDW . phgeenzoik = true ; rtDW . and0otfyv2 = ssGetTaskTime ( rtS , 1 ) ; rtDW . habwkca01a = ( rtMinusInf ) ; rtDW . oktrhzldpx = 0ULL ; } void MdlStart ( void ) { CXPtMax * _rtXPerturbMax ; CXPtMin * _rtXPerturbMin ; NeModelParameters modelParameters ; NeModelParameters modelParameters_e ; NeModelParameters modelParameters_p ; NeslSimulationData * simulationData ; NeslSimulator * tmp ; NeuDiagnosticManager * diagnosticManager ; NeuDiagnosticTree * diagnosticTree ; NeuDiagnosticTree * diagnosticTree_e ; NeuDiagnosticTree * diagnosticTree_g ; NeuDiagnosticTree * diagnosticTree_i ; NeuDiagnosticTree * diagnosticTree_m ; NeuDiagnosticTree * diagnosticTree_p ; SscInstRtwLogging * tmp_b ; SscRTWLogFcnManager * rtwLogManager ; SscRTWLogFcnManager * rtwLogManager_p ; char * msg ; char * msg_e ; char * msg_g ; char * msg_i ; char * msg_m ; char * msg_p ; real_T tmp_c [ 4 ] ; real_T tmp_j [ 4 ] ; real_T tmp_m [ 4 ] ; real_T time ; real_T time_e ; real_T time_p ; real_T tmp_e ; int32_T tmp_i ; int_T tmp_f [ 2 ] ; int_T tmp_g [ 2 ] ; int_T tmp_k [ 2 ] ; boolean_T directFeedThrough [ 2 ] ; boolean_T directFeedThrough_e [ 2 ] ; boolean_T directFeedThrough_p [ 2 ] ; boolean_T tmp_p ; boolean_T val ; { bool externalInputIsInDatasetFormat = false ; void * pISigstreamManager = rt_GetISigstreamManager ( rtS ) ; rtwISigstreamManagerGetInputIsInDatasetFormat ( pISigstreamManager , & externalInputIsInDatasetFormat ) ; if ( externalInputIsInDatasetFormat ) { } } _rtXPerturbMax = ( ( CXPtMax * ) ssGetJacobianPerturbationBoundsMaxVec ( rtS ) ) ; _rtXPerturbMin = ( ( CXPtMin * ) ssGetJacobianPerturbationBoundsMinVec ( rtS ) ) ; rtDW . fqcwpuiypl = 0 ; rtDW . ilpdoalijh = 0 ; rtDW . gr1pr4ue0h = 0 ; tmp = nesl_lease_simulator ( "boat/Solver Configuration1_1" , 0 , 0 ) ; rtDW . nzbcd4gsn0 = ( void * ) tmp ; tmp_p = pointer_is_null ( rtDW . nzbcd4gsn0 ) ; if ( tmp_p ) { boat_2920769f_1_gateway ( ) ; tmp = nesl_lease_simulator ( "boat/Solver Configuration1_1" , 0 , 0 ) ; rtDW . nzbcd4gsn0 = ( void * ) tmp ; } slsaSaveRawMemoryForSimTargetOP ( rtS , "boat/Solver Configuration1_100" , ( void * * ) ( & rtDW . nzbcd4gsn0 ) , 0U * sizeof ( real_T ) , nesl_save_simdata , nesl_restore_simdata ) ; simulationData = nesl_create_simulation_data ( ) ; rtDW . matviv3tsc = ( void * ) simulationData ; diagnosticManager = rtw_create_diagnostics ( ) ; rtDW . ncn0gprufm = ( void * ) diagnosticManager ; modelParameters . mSolverType = NE_SOLVER_TYPE_DAE ; modelParameters . mSolverAbsTol = 0.001 ; modelParameters . mSolverRelTol = 0.001 ; modelParameters . mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_MAYBE ; modelParameters . mStartTime = 0.0 ; modelParameters . mLoadInitialState = false ; modelParameters . mUseSimState = false ; modelParameters . mLinTrimCompile = false ; modelParameters . mLoggingMode = SSC_LOGGING_INST ; modelParameters . mRTWModifiedTimeStamp = 6.5222342E+8 ; modelParameters . mZcDisabled = false ; modelParameters . mUseModelRefSolver = false ; modelParameters . mTargetFPGAHIL = false ; tmp_e = 0.001 ; modelParameters . mSolverTolerance = tmp_e ; tmp_e = 0.0 ; modelParameters . mFixedStepSize = tmp_e ; tmp_p = true ; modelParameters . mVariableStepSolver = tmp_p ; tmp_p = false ; modelParameters . mIsUsingODEN = tmp_p ; tmp_p = slIsRapidAcceleratorSimulating ( ) ; val = ssGetGlobalInitialStatesAvailable ( rtS ) ; if ( tmp_p ) { val = ( val && ssIsFirstInitCond ( rtS ) ) ; } modelParameters . mLoadInitialState = val ; modelParameters . mZcDisabled = false ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . ncn0gprufm ; diagnosticTree = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = nesl_initialize_simulator ( ( NeslSimulator * ) rtDW . nzbcd4gsn0 , & modelParameters , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp_p = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp_p ) { msg = rtw_diagnostics_msg ( diagnosticTree ) ; ssSetErrorStatus ( rtS , msg ) ; } } simulationData = ( NeslSimulationData * ) rtDW . matviv3tsc ; time = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time ; simulationData -> mData -> mContStates . mN = 3 ; simulationData -> mData -> mContStates . mX = & rtX . cbt50efduc [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 0 ; simulationData -> mData -> mDiscStates . mX = & rtDW . m5zbqevzsx ; simulationData -> mData -> mModeVector . mN = 0 ; simulationData -> mData -> mModeVector . mX = & rtDW . hgyea5eklz ; tmp_p = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp_p ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp_p = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp_p ; tmp_p = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp_p ; tmp_p = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp_p ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp_p = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp_p ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_g [ 0 ] = 0 ; tmp_m [ 0 ] = rtB . fsw1z0i2v1 [ 0 ] ; tmp_m [ 1 ] = rtB . fsw1z0i2v1 [ 1 ] ; tmp_m [ 2 ] = rtB . fsw1z0i2v1 [ 2 ] ; tmp_m [ 3 ] = rtB . fsw1z0i2v1 [ 3 ] ; tmp_g [ 1 ] = 4 ; simulationData -> mData -> mInputValues . mN = 4 ; simulationData -> mData -> mInputValues . mX = & tmp_m [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 2 ; simulationData -> mData -> mInputOffsets . mX = & tmp_g [ 0 ] ; simulationData -> mData -> mNumjacDxLo . mN = 3 ; simulationData -> mData -> mNumjacDxLo . mX = & _rtXPerturbMin -> cbt50efduc [ 0 ] ; simulationData -> mData -> mNumjacDxHi . mN = 3 ; simulationData -> mData -> mNumjacDxHi . mX = & _rtXPerturbMax -> cbt50efduc [ 0 ] ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . ncn0gprufm ; diagnosticTree_p = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = ne_simulator_method ( ( NeslSimulator * ) rtDW . nzbcd4gsn0 , NESL_SIM_NUMJAC_DX_BOUNDS , simulationData , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp_p = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp_p ) { msg_p = rtw_diagnostics_msg ( diagnosticTree_p ) ; ssSetErrorStatus ( rtS , msg_p ) ; } } rtDW . nmot3ctkc4 = true ; tmp = nesl_lease_simulator ( "boat/Solver Configuration_1" , 0 , 0 ) ; rtDW . brvpxkjfg4 = ( void * ) tmp ; tmp_p = pointer_is_null ( rtDW . brvpxkjfg4 ) ; if ( tmp_p ) { boat_57910a22_1_gateway ( ) ; tmp = nesl_lease_simulator ( "boat/Solver Configuration_1" , 0 , 0 ) ; rtDW . brvpxkjfg4 = ( void * ) tmp ; } slsaSaveRawMemoryForSimTargetOP ( rtS , "boat/Solver Configuration_100" , ( void * * ) ( & rtDW . brvpxkjfg4 ) , 0U * sizeof ( real_T ) , nesl_save_simdata , nesl_restore_simdata ) ; simulationData = nesl_create_simulation_data ( ) ; rtDW . mdrfbzfj35 = ( void * ) simulationData ; diagnosticManager = rtw_create_diagnostics ( ) ; rtDW . o3nzm0dbcw = ( void * ) diagnosticManager ; modelParameters_p . mSolverType = NE_SOLVER_TYPE_DAE ; modelParameters_p . mSolverAbsTol = 0.001 ; modelParameters_p . mSolverRelTol = 0.001 ; modelParameters_p . mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_MAYBE ; modelParameters_p . mStartTime = 0.0 ; modelParameters_p . mLoadInitialState = false ; modelParameters_p . mUseSimState = false ; modelParameters_p . mLinTrimCompile = false ; modelParameters_p . mLoggingMode = SSC_LOGGING_INST ; modelParameters_p . mRTWModifiedTimeStamp = 6.5222342E+8 ; modelParameters_p . mZcDisabled = false ; modelParameters_p . mUseModelRefSolver = false ; modelParameters_p . mTargetFPGAHIL = false ; tmp_e = 0.001 ; modelParameters_p . mSolverTolerance = tmp_e ; tmp_e = 0.0 ; modelParameters_p . mFixedStepSize = tmp_e ; tmp_p = true ; modelParameters_p . mVariableStepSolver = tmp_p ; tmp_p = false ; modelParameters_p . mIsUsingODEN = tmp_p ; tmp_p = slIsRapidAcceleratorSimulating ( ) ; val = ssGetGlobalInitialStatesAvailable ( rtS ) ; if ( tmp_p ) { val = ( val && ssIsFirstInitCond ( rtS ) ) ; } modelParameters_p . mLoadInitialState = val ; modelParameters_p . mZcDisabled = false ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . o3nzm0dbcw ; diagnosticTree_e = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = nesl_initialize_simulator ( ( NeslSimulator * ) rtDW . brvpxkjfg4 , & modelParameters_p , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp_p = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp_p ) { msg_e = rtw_diagnostics_msg ( diagnosticTree_e ) ; ssSetErrorStatus ( rtS , msg_e ) ; } } simulationData = ( NeslSimulationData * ) rtDW . mdrfbzfj35 ; time_p = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_p ; simulationData -> mData -> mContStates . mN = 3 ; simulationData -> mData -> mContStates . mX = & rtX . fbrr2x2skx [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 0 ; simulationData -> mData -> mDiscStates . mX = & rtDW . idc5s0rsfa ; simulationData -> mData -> mModeVector . mN = 0 ; simulationData -> mData -> mModeVector . mX = & rtDW . gsaeaqfztj ; tmp_p = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp_p ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp_p = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp_p ; tmp_p = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp_p ; tmp_p = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp_p ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp_p = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp_p ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_f [ 0 ] = 0 ; tmp_j [ 0 ] = rtB . agudjbqwit [ 0 ] ; tmp_j [ 1 ] = rtB . agudjbqwit [ 1 ] ; tmp_j [ 2 ] = rtB . agudjbqwit [ 2 ] ; tmp_j [ 3 ] = rtB . agudjbqwit [ 3 ] ; tmp_f [ 1 ] = 4 ; simulationData -> mData -> mInputValues . mN = 4 ; simulationData -> mData -> mInputValues . mX = & tmp_j [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 2 ; simulationData -> mData -> mInputOffsets . mX = & tmp_f [ 0 ] ; simulationData -> mData -> mNumjacDxLo . mN = 3 ; simulationData -> mData -> mNumjacDxLo . mX = & _rtXPerturbMin -> fbrr2x2skx [ 0 ] ; simulationData -> mData -> mNumjacDxHi . mN = 3 ; simulationData -> mData -> mNumjacDxHi . mX = & _rtXPerturbMax -> fbrr2x2skx [ 0 ] ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . o3nzm0dbcw ; diagnosticTree_i = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = ne_simulator_method ( ( NeslSimulator * ) rtDW . brvpxkjfg4 , NESL_SIM_NUMJAC_DX_BOUNDS , simulationData , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp_p = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp_p ) { msg_i = rtw_diagnostics_msg ( diagnosticTree_i ) ; ssSetErrorStatus ( rtS , msg_i ) ; } } rtDW . gb30213u1q = true ; tmp = nesl_lease_simulator ( "boat/Solver Configuration2_1" , 0 , 0 ) ; rtDW . b4ovldmiyf = ( void * ) tmp ; tmp_p = pointer_is_null ( rtDW . b4ovldmiyf ) ; if ( tmp_p ) { boat_5e274609_1_gateway ( ) ; tmp = nesl_lease_simulator ( "boat/Solver Configuration2_1" , 0 , 0 ) ; rtDW . b4ovldmiyf = ( void * ) tmp ; } slsaSaveRawMemoryForSimTargetOP ( rtS , "boat/Solver Configuration2_100" , ( void * * ) ( & rtDW . b4ovldmiyf ) , 0U * sizeof ( real_T ) , nesl_save_simdata , nesl_restore_simdata ) ; simulationData = nesl_create_simulation_data ( ) ; rtDW . eg2dr13w4n = ( void * ) simulationData ; diagnosticManager = rtw_create_diagnostics ( ) ; rtDW . deu0nhli3p = ( void * ) diagnosticManager ; modelParameters_e . mSolverType = NE_SOLVER_TYPE_DAE ; modelParameters_e . mSolverAbsTol = 0.001 ; modelParameters_e . mSolverRelTol = 0.001 ; modelParameters_e . mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_MAYBE ; modelParameters_e . mStartTime = 0.0 ; modelParameters_e . mLoadInitialState = false ; modelParameters_e . mUseSimState = false ; modelParameters_e . mLinTrimCompile = false ; modelParameters_e . mLoggingMode = SSC_LOGGING_INST ; modelParameters_e . mRTWModifiedTimeStamp = 6.52224856E+8 ; modelParameters_e . mZcDisabled = false ; modelParameters_e . mUseModelRefSolver = false ; modelParameters_e . mTargetFPGAHIL = false ; tmp_e = 0.001 ; modelParameters_e . mSolverTolerance = tmp_e ; tmp_e = 0.0 ; modelParameters_e . mFixedStepSize = tmp_e ; tmp_p = true ; modelParameters_e . mVariableStepSolver = tmp_p ; tmp_p = false ; modelParameters_e . mIsUsingODEN = tmp_p ; tmp_p = slIsRapidAcceleratorSimulating ( ) ; val = ssGetGlobalInitialStatesAvailable ( rtS ) ; if ( tmp_p ) { val = ( val && ssIsFirstInitCond ( rtS ) ) ; } modelParameters_e . mLoadInitialState = val ; modelParameters_e . mZcDisabled = false ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . deu0nhli3p ; diagnosticTree_m = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = nesl_initialize_simulator ( ( NeslSimulator * ) rtDW . b4ovldmiyf , & modelParameters_e , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp_p = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp_p ) { msg_m = rtw_diagnostics_msg ( diagnosticTree_m ) ; ssSetErrorStatus ( rtS , msg_m ) ; } } simulationData = ( NeslSimulationData * ) rtDW . eg2dr13w4n ; time_e = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_e ; simulationData -> mData -> mContStates . mN = 3 ; simulationData -> mData -> mContStates . mX = & rtX . mqsayiekhp [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 0 ; simulationData -> mData -> mDiscStates . mX = & rtDW . oq4y10dztc ; simulationData -> mData -> mModeVector . mN = 0 ; simulationData -> mData -> mModeVector . mX = & rtDW . bfxht5ivew ; tmp_p = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp_p ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp_p = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp_p ; tmp_p = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp_p ; tmp_p = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp_p ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp_p = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp_p ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_k [ 0 ] = 0 ; tmp_c [ 0 ] = rtB . ivckfgwj3f [ 0 ] ; tmp_c [ 1 ] = rtB . ivckfgwj3f [ 1 ] ; tmp_c [ 2 ] = rtB . ivckfgwj3f [ 2 ] ; tmp_c [ 3 ] = rtB . ivckfgwj3f [ 3 ] ; tmp_k [ 1 ] = 4 ; simulationData -> mData -> mInputValues . mN = 4 ; simulationData -> mData -> mInputValues . mX = & tmp_c [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 2 ; simulationData -> mData -> mInputOffsets . mX = & tmp_k [ 0 ] ; simulationData -> mData -> mNumjacDxLo . mN = 3 ; simulationData -> mData -> mNumjacDxLo . mX = & _rtXPerturbMin -> mqsayiekhp [ 0 ] ; simulationData -> mData -> mNumjacDxHi . mN = 3 ; simulationData -> mData -> mNumjacDxHi . mX = & _rtXPerturbMax -> mqsayiekhp [ 0 ] ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . deu0nhli3p ; diagnosticTree_g = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = ne_simulator_method ( ( NeslSimulator * ) rtDW . b4ovldmiyf , NESL_SIM_NUMJAC_DX_BOUNDS , simulationData , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp_p = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp_p ) { msg_g = rtw_diagnostics_msg ( diagnosticTree_g ) ; ssSetErrorStatus ( rtS , msg_g ) ; } } rtDW . aen5lyyfuu = true ; directFeedThrough [ 0 ] = true ; directFeedThrough [ 1 ] = true ; rtwLogManager_p = ssc_lease_rtw_log_fcn_manager ( "boat/Solver Configuration_1" , 0 , 2U , directFeedThrough , 4U , 36U ) ; rtwLogManager = rtwLogManager_p ; tmp_p = pointer_is_null ( rtwLogManager_p ) ; if ( tmp_p ) { boat_57910a22_1_gateway ( ) ; rtwLogManager = ssc_lease_rtw_log_fcn_manager ( "boat/Solver Configuration_1" , 0 , 2U , directFeedThrough , 4U , 36U ) ; } rtDW . nkek3zr1jv = ( void * ) rtwLogManager ; if ( rtDW . nkek3zr1jv != NULL ) { ssc_rtw_setup_log_fcn ( rtDW . nkek3zr1jv ) ; } rtDW . g1mp4mth5z = calloc ( 36U , 8U ) ; tmp_b = ssc_inst_rtw_make_logging_struct ( "boat" , "Solver Configuration/EVAL_KEY/SINK_1" , "F:\\Programming\\P761\\Simulink\\slprj\\raccel\\boat\\76ede66c-f1f8-46f6-b1cc-3dd9617f3d39_ssc_logging_meta_data" , 1U ) ; rtDW . hui0e3sc54 = ( void * ) tmp_b ; ssc_inst_logger_start ( rtDW . hui0e3sc54 ) ; directFeedThrough_p [ 0 ] = true ; directFeedThrough_p [ 1 ] = true ; rtwLogManager_p = ssc_lease_rtw_log_fcn_manager ( "boat/Solver Configuration1_1" , 0 , 2U , directFeedThrough_p , 4U , 36U ) ; rtwLogManager = rtwLogManager_p ; tmp_p = pointer_is_null ( rtwLogManager_p ) ; if ( tmp_p ) { boat_2920769f_1_gateway ( ) ; rtwLogManager = ssc_lease_rtw_log_fcn_manager ( "boat/Solver Configuration1_1" , 0 , 2U , directFeedThrough_p , 4U , 36U ) ; } rtDW . mfnn1vwzpe = ( void * ) rtwLogManager ; if ( rtDW . mfnn1vwzpe != NULL ) { ssc_rtw_setup_log_fcn ( rtDW . mfnn1vwzpe ) ; } rtDW . gqh21g1lhv = calloc ( 36U , 8U ) ; tmp_b = ssc_inst_rtw_make_logging_struct ( "boat" , "Solver Configuration1/EVAL_KEY/SINK_1" , "F:\\Programming\\P761\\Simulink\\slprj\\raccel\\boat\\6d1cd8f1-cbb6-43d4-8a5b-92cda59dd0ef_ssc_logging_meta_data" , 1U ) ; rtDW . hhqju1srnf = ( void * ) tmp_b ; ssc_inst_logger_start ( rtDW . hhqju1srnf ) ; directFeedThrough_e [ 0 ] = true ; directFeedThrough_e [ 1 ] = true ; rtwLogManager_p = ssc_lease_rtw_log_fcn_manager ( "boat/Solver Configuration2_1" , 0 , 2U , directFeedThrough_e , 4U , 36U ) ; rtwLogManager = rtwLogManager_p ; tmp_p = pointer_is_null ( rtwLogManager_p ) ; if ( tmp_p ) { boat_5e274609_1_gateway ( ) ; rtwLogManager = ssc_lease_rtw_log_fcn_manager ( "boat/Solver Configuration2_1" , 0 , 2U , directFeedThrough_e , 4U , 36U ) ; } rtDW . mo5hgh4mup = ( void * ) rtwLogManager ; if ( rtDW . mo5hgh4mup != NULL ) { ssc_rtw_setup_log_fcn ( rtDW . mo5hgh4mup ) ; } rtDW . kyjulrp02t = calloc ( 36U , 8U ) ; tmp_b = ssc_inst_rtw_make_logging_struct ( "boat" , "Solver Configuration2/EVAL_KEY/SINK_1" , "F:\\Programming\\P761\\Simulink\\slprj\\raccel\\boat\\b14826bc-518f-43b3-9e68-a13406e955d0_ssc_logging_meta_data" , 1U ) ; rtDW . nuu25nvw2m = ( void * ) tmp_b ; ssc_inst_logger_start ( rtDW . nuu25nvw2m ) ; MdlInitialize ( ) ; MdlEnable ( ) ; } void MdlOutputs ( int_T tid ) { NeslSimulationData * simulationData ; NeuDiagnosticManager * diagnosticManager ; NeuDiagnosticTree * diagnosticTree ; NeuDiagnosticTree * diagnosticTree_e ; NeuDiagnosticTree * diagnosticTree_p ; char * msg ; char * msg_e ; char * msg_p ; real_T tmp_b [ 7 ] ; real_T tmp_c [ 7 ] ; real_T tmp_k [ 7 ] ; real_T tmp_j [ 4 ] ; real_T tmp_m [ 4 ] ; real_T tmp_p [ 4 ] ; real_T h3vcrqruvg ; real_T time ; real_T time_e ; real_T time_g ; real_T time_i ; real_T time_m ; real_T time_p ; real_T tmp_l ; real_T tmp_n ; int32_T tmp_i ; int_T tmp_e [ 2 ] ; int_T tmp_f [ 2 ] ; int_T tmp_g [ 2 ] ; boolean_T tmp ; rtB . dr3d0f4ilc = rtX . f2d4l4jl4s ; rtB . jsslo5nqyh = rtP . Constant6_Value - rtB . dr3d0f4ilc ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtDW . nnoau3gejb = ( rtB . jsslo5nqyh >= 0.0 ) ; } if ( rtDW . nnoau3gejb > 0 ) { rtB . f5xxv5c5iw = rtB . jsslo5nqyh ; } else { rtB . f5xxv5c5iw = - rtB . jsslo5nqyh ; } rtB . e1tauwrvu3 = rtX . eqm01ekw05 ; rtB . a44cutexgr = rtP . Constant6_Value - rtB . e1tauwrvu3 ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtDW . bexc5hutlj = ( rtB . a44cutexgr >= 0.0 ) ; } if ( rtDW . bexc5hutlj > 0 ) { rtB . hm1wvbykyh = rtB . a44cutexgr ; } else { rtB . hm1wvbykyh = - rtB . a44cutexgr ; } rtB . egfw2eqq25 = rtX . llcy0vep2l ; rtB . a4iypm4gbs = rtP . Constant6_Value - rtB . egfw2eqq25 ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtDW . hq42bs4esx = ( rtB . a4iypm4gbs >= 0.0 ) ; } if ( rtDW . hq42bs4esx > 0 ) { rtB . itjs0jtx3o = rtB . a4iypm4gbs ; } else { rtB . itjs0jtx3o = - rtB . a4iypm4gbs ; } rtB . pkrzvdzw1y = rtX . kv3akytruj ; rtB . i1d5qqrmac = rtP . PIDController_D * rtB . f5xxv5c5iw ; rtB . cf5qjarukv = rtX . ecyoj2i3gw ; rtB . ab13ugd0jb = rtB . i1d5qqrmac - rtB . cf5qjarukv ; rtB . ckxmfogvuu = rtP . PIDController_N * rtB . ab13ugd0jb ; rtB . a3vetqfkld = ( rtP . PIDController_P * rtB . f5xxv5c5iw + rtB . pkrzvdzw1y ) + rtB . ckxmfogvuu ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { if ( rtB . a3vetqfkld >= rtP . Dutycyclelimit003_UpperSat ) { rtDW . cr5oo1xudj = 1 ; } else if ( rtB . a3vetqfkld > rtP . Dutycyclelimit003_LowerSat ) { rtDW . cr5oo1xudj = 0 ; } else { rtDW . cr5oo1xudj = - 1 ; } } if ( rtDW . cr5oo1xudj == 1 ) { rtB . iuoeijrbuw = rtP . Dutycyclelimit003_UpperSat ; } else if ( rtDW . cr5oo1xudj == - 1 ) { rtB . iuoeijrbuw = rtP . Dutycyclelimit003_LowerSat ; } else { rtB . iuoeijrbuw = rtB . a3vetqfkld ; } if ( ssIsSampleHit ( rtS , 5 , 0 ) ) { if ( ( rtB . iuoeijrbuw * rtP . PWM_Period + ssGetTaskTime ( rtS , 1 ) <= ssGetTaskTime ( rtS , 1 ) + 2.8421709430404007E-14 ) && rtDW . n52coetlf4 ) { rtB . poqfyzkjha = 0.0 ; rtDW . ozkuq5jrkw = false ; } else { rtB . poqfyzkjha = rtDW . ozkuq5jrkw ; } } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { } rtB . bivog3ueus = rtX . g13n4kjtrj ; rtB . omdp2bmrlk = rtP . PIDController1_D * rtB . hm1wvbykyh ; rtB . mfrwttvwxf = rtX . bgucvxka1s ; rtB . fkvci5gmb2 = rtB . omdp2bmrlk - rtB . mfrwttvwxf ; rtB . ny5ud0kux2 = rtP . PIDController1_N * rtB . fkvci5gmb2 ; rtB . objm10tupt = ( rtP . PIDController1_P * rtB . hm1wvbykyh + rtB . bivog3ueus ) + rtB . ny5ud0kux2 ; rtB . jhzetj2jj0 = rtX . lgrsqc5d1d ; rtB . mazeb5zpdw = rtP . PIDController2_D * rtB . itjs0jtx3o ; rtB . k0d05v5dag = rtX . fmj0130ch2 ; rtB . lbb2jr05jy = rtB . mazeb5zpdw - rtB . k0d05v5dag ; rtB . mm1pucs154 = rtP . PIDController2_N * rtB . lbb2jr05jy ; rtB . iokldrmvxg = ( rtP . PIDController2_P * rtB . itjs0jtx3o + rtB . jhzetj2jj0 ) + rtB . mm1pucs154 ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { if ( rtB . objm10tupt >= rtP . Dutycyclelimit001_UpperSat ) { rtDW . akw4wluyho = 1 ; } else if ( rtB . objm10tupt > rtP . Dutycyclelimit001_LowerSat ) { rtDW . akw4wluyho = 0 ; } else { rtDW . akw4wluyho = - 1 ; } } if ( rtDW . akw4wluyho == 1 ) { rtB . lerfsdmwkn = rtP . Dutycyclelimit001_UpperSat ; } else if ( rtDW . akw4wluyho == - 1 ) { rtB . lerfsdmwkn = rtP . Dutycyclelimit001_LowerSat ; } else { rtB . lerfsdmwkn = rtB . objm10tupt ; } if ( ssIsSampleHit ( rtS , 3 , 0 ) ) { if ( ( rtB . lerfsdmwkn * rtP . PWM1_Period + ssGetTaskTime ( rtS , 1 ) <= ssGetTaskTime ( rtS , 1 ) + 2.8421709430404007E-14 ) && rtDW . gbzgjra1qd ) { rtB . bpxugea0p4 = 0.0 ; rtDW . fgliutlg4v = false ; } else { rtB . bpxugea0p4 = rtDW . fgliutlg4v ; } } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { } if ( ssIsModeUpdateTimeStep ( rtS ) ) { if ( rtB . iokldrmvxg >= rtP . Dutycyclelimit002_UpperSat ) { rtDW . ks031m0ijp = 1 ; } else if ( rtB . iokldrmvxg > rtP . Dutycyclelimit002_LowerSat ) { rtDW . ks031m0ijp = 0 ; } else { rtDW . ks031m0ijp = - 1 ; } } if ( rtDW . ks031m0ijp == 1 ) { rtB . aucpl4jwuv = rtP . Dutycyclelimit002_UpperSat ; } else if ( rtDW . ks031m0ijp == - 1 ) { rtB . aucpl4jwuv = rtP . Dutycyclelimit002_LowerSat ; } else { rtB . aucpl4jwuv = rtB . iokldrmvxg ; } if ( ssIsSampleHit ( rtS , 4 , 0 ) ) { if ( ( rtB . aucpl4jwuv * rtP . PWM2_Period + ssGetTaskTime ( rtS , 1 ) <= ssGetTaskTime ( rtS , 1 ) + 2.8421709430404007E-14 ) && rtDW . phgeenzoik ) { rtB . pgjji1gn55 = 0.0 ; rtDW . kdmfiti23w = false ; } else { rtB . pgjji1gn55 = rtDW . kdmfiti23w ; } } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { } if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtB . occj1ixdmt = rtP . Output_Gain * rtDW . k4wpb4vucr ; } rtB . ghrwyo3imw [ 0 ] = rtB . egfw2eqq25 + rtB . occj1ixdmt ; rtB . ghrwyo3imw [ 1 ] = rtB . e1tauwrvu3 + rtB . occj1ixdmt ; rtB . ghrwyo3imw [ 2 ] = rtB . dr3d0f4ilc + rtB . occj1ixdmt ; if ( rtDW . nmot3ctkc4 ) { simulationData = ( NeslSimulationData * ) rtDW . matviv3tsc ; time = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time ; simulationData -> mData -> mContStates . mN = 3 ; simulationData -> mData -> mContStates . mX = & rtX . cbt50efduc [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 0 ; simulationData -> mData -> mDiscStates . mX = & rtDW . m5zbqevzsx ; simulationData -> mData -> mModeVector . mN = 0 ; simulationData -> mData -> mModeVector . mX = & rtDW . hgyea5eklz ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_e [ 0 ] = 0 ; tmp_p [ 0 ] = rtB . fsw1z0i2v1 [ 0 ] ; tmp_p [ 1 ] = rtB . fsw1z0i2v1 [ 1 ] ; tmp_p [ 2 ] = rtB . fsw1z0i2v1 [ 2 ] ; tmp_p [ 3 ] = rtB . fsw1z0i2v1 [ 3 ] ; tmp_e [ 1 ] = 4 ; simulationData -> mData -> mInputValues . mN = 4 ; simulationData -> mData -> mInputValues . mX = & tmp_p [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 2 ; simulationData -> mData -> mInputOffsets . mX = & tmp_e [ 0 ] ; simulationData -> mData -> mOutputs . mN = 3 ; simulationData -> mData -> mOutputs . mX = & rtB . p3ofdssvna [ 0 ] ; simulationData -> mData -> mTolerances . mN = 0 ; simulationData -> mData -> mTolerances . mX = NULL ; simulationData -> mData -> mCstateHasChanged = false ; simulationData -> mData -> mDstateHasChanged = false ; time_p = ssGetTaskTime ( rtS , 0 ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_p ; simulationData -> mData -> mSampleHits . mN = 0 ; simulationData -> mData -> mSampleHits . mX = NULL ; simulationData -> mData -> mIsFundamentalSampleHit = false ; simulationData -> mData -> mHadEvents = false ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . ncn0gprufm ; diagnosticTree = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = ne_simulator_method ( ( NeslSimulator * ) rtDW . nzbcd4gsn0 , NESL_SIM_OUTPUTS , simulationData , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg = rtw_diagnostics_msg ( diagnosticTree ) ; ssSetErrorStatus ( rtS , msg ) ; } } if ( ssIsMajorTimeStep ( rtS ) && simulationData -> mData -> mCstateHasChanged ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; } rtDW . nmot3ctkc4 = false ; } else { rtB . p3ofdssvna [ 0 ] = rtX . cbt50efduc [ 0 ] ; rtB . p3ofdssvna [ 1 ] = rtX . cbt50efduc [ 1 ] ; rtB . p3ofdssvna [ 2 ] = rtX . cbt50efduc [ 2 ] ; } rtB . cujjmjv5eq = 0.0 ; rtB . cujjmjv5eq += rtB . p3ofdssvna [ 0 ] ; psywd01xtt ( rtB . e1tauwrvu3 , rtB . cujjmjv5eq , & rtB . hbgiv4wxgq , & rtDW . hbgiv4wxgq ) ; ldzksap41j ( rtB . hbgiv4wxgq . ippecxjt0i , rtB . b4feafyt4o , rtB . egfw2eqq25 , & rtB . nf1oadke3r , & rtDW . nf1oadke3r ) ; if ( rtDW . gb30213u1q ) { simulationData = ( NeslSimulationData * ) rtDW . mdrfbzfj35 ; time_e = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_e ; simulationData -> mData -> mContStates . mN = 3 ; simulationData -> mData -> mContStates . mX = & rtX . fbrr2x2skx [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 0 ; simulationData -> mData -> mDiscStates . mX = & rtDW . idc5s0rsfa ; simulationData -> mData -> mModeVector . mN = 0 ; simulationData -> mData -> mModeVector . mX = & rtDW . gsaeaqfztj ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_g [ 0 ] = 0 ; tmp_m [ 0 ] = rtB . agudjbqwit [ 0 ] ; tmp_m [ 1 ] = rtB . agudjbqwit [ 1 ] ; tmp_m [ 2 ] = rtB . agudjbqwit [ 2 ] ; tmp_m [ 3 ] = rtB . agudjbqwit [ 3 ] ; tmp_g [ 1 ] = 4 ; simulationData -> mData -> mInputValues . mN = 4 ; simulationData -> mData -> mInputValues . mX = & tmp_m [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 2 ; simulationData -> mData -> mInputOffsets . mX = & tmp_g [ 0 ] ; simulationData -> mData -> mOutputs . mN = 3 ; simulationData -> mData -> mOutputs . mX = & rtB . ilgweckhrc [ 0 ] ; simulationData -> mData -> mTolerances . mN = 0 ; simulationData -> mData -> mTolerances . mX = NULL ; simulationData -> mData -> mCstateHasChanged = false ; simulationData -> mData -> mDstateHasChanged = false ; time_i = ssGetTaskTime ( rtS , 0 ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_i ; simulationData -> mData -> mSampleHits . mN = 0 ; simulationData -> mData -> mSampleHits . mX = NULL ; simulationData -> mData -> mIsFundamentalSampleHit = false ; simulationData -> mData -> mHadEvents = false ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . o3nzm0dbcw ; diagnosticTree_p = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = ne_simulator_method ( ( NeslSimulator * ) rtDW . brvpxkjfg4 , NESL_SIM_OUTPUTS , simulationData , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg_p = rtw_diagnostics_msg ( diagnosticTree_p ) ; ssSetErrorStatus ( rtS , msg_p ) ; } } if ( ssIsMajorTimeStep ( rtS ) && simulationData -> mData -> mCstateHasChanged ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; } rtDW . gb30213u1q = false ; } else { rtB . ilgweckhrc [ 0 ] = rtX . fbrr2x2skx [ 0 ] ; rtB . ilgweckhrc [ 1 ] = rtX . fbrr2x2skx [ 1 ] ; rtB . ilgweckhrc [ 2 ] = rtX . fbrr2x2skx [ 2 ] ; } rtB . aglzt1mdnj = 0.0 ; rtB . aglzt1mdnj += rtB . ilgweckhrc [ 1 ] ; psywd01xtt ( rtB . dr3d0f4ilc , rtB . aglzt1mdnj , & rtB . ifmn2jhohh , & rtDW . ifmn2jhohh ) ; ldzksap41j ( rtB . ifmn2jhohh . ippecxjt0i , rtB . kizl3igrxr , rtB . egfw2eqq25 , & rtB . fmscqp2pk3 , & rtDW . fmscqp2pk3 ) ; if ( rtDW . aen5lyyfuu ) { simulationData = ( NeslSimulationData * ) rtDW . eg2dr13w4n ; time_m = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_m ; simulationData -> mData -> mContStates . mN = 3 ; simulationData -> mData -> mContStates . mX = & rtX . mqsayiekhp [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 0 ; simulationData -> mData -> mDiscStates . mX = & rtDW . oq4y10dztc ; simulationData -> mData -> mModeVector . mN = 0 ; simulationData -> mData -> mModeVector . mX = & rtDW . bfxht5ivew ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_f [ 0 ] = 0 ; tmp_j [ 0 ] = rtB . ivckfgwj3f [ 0 ] ; tmp_j [ 1 ] = rtB . ivckfgwj3f [ 1 ] ; tmp_j [ 2 ] = rtB . ivckfgwj3f [ 2 ] ; tmp_j [ 3 ] = rtB . ivckfgwj3f [ 3 ] ; tmp_f [ 1 ] = 4 ; simulationData -> mData -> mInputValues . mN = 4 ; simulationData -> mData -> mInputValues . mX = & tmp_j [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 2 ; simulationData -> mData -> mInputOffsets . mX = & tmp_f [ 0 ] ; simulationData -> mData -> mOutputs . mN = 3 ; simulationData -> mData -> mOutputs . mX = & rtB . f2ol5xfubh [ 0 ] ; simulationData -> mData -> mTolerances . mN = 0 ; simulationData -> mData -> mTolerances . mX = NULL ; simulationData -> mData -> mCstateHasChanged = false ; simulationData -> mData -> mDstateHasChanged = false ; time_g = ssGetTaskTime ( rtS , 0 ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_g ; simulationData -> mData -> mSampleHits . mN = 0 ; simulationData -> mData -> mSampleHits . mX = NULL ; simulationData -> mData -> mIsFundamentalSampleHit = false ; simulationData -> mData -> mHadEvents = false ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . deu0nhli3p ; diagnosticTree_e = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = ne_simulator_method ( ( NeslSimulator * ) rtDW . b4ovldmiyf , NESL_SIM_OUTPUTS , simulationData , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg_e = rtw_diagnostics_msg ( diagnosticTree_e ) ; ssSetErrorStatus ( rtS , msg_e ) ; } } if ( ssIsMajorTimeStep ( rtS ) && simulationData -> mData -> mCstateHasChanged ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; } rtDW . aen5lyyfuu = false ; } else { rtB . f2ol5xfubh [ 0 ] = rtX . mqsayiekhp [ 0 ] ; rtB . f2ol5xfubh [ 1 ] = rtX . mqsayiekhp [ 1 ] ; rtB . f2ol5xfubh [ 2 ] = rtX . mqsayiekhp [ 2 ] ; } rtB . lg4f4t2001 = 0.0 ; rtB . lg4f4t2001 += rtB . f2ol5xfubh [ 1 ] ; rtB . pxqsiby1mn = rtB . keqzqlqvew * rtB . aghkd4traa * rtB . lg4f4t2001 ; rtB . exa5xkuexf = rtB . n3sn4i2y20 * rtB . i3trgao54h * rtB . ifmn2jhohh . ippecxjt0i ; if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtB . h5spww2eug = rtP . Driftcausedbywindforce_Gain * rtDW . k1sbpk4k2l ; } rtB . dtgw2eazth = rtX . de235fb3n0 ; rtB . c5yrhsrtms = rtB . dtgw2eazth * rtP . drag2_Value ; rtB . iosioblynm = rtB . if2ghcwui3 * rtB . dn41zbwev0 * rtB . hbgiv4wxgq . ippecxjt0i ; rtB . fs1xewuk02 = ( ( ( rtB . pxqsiby1mn + rtB . exa5xkuexf ) + rtB . h5spww2eug ) + rtB . c5yrhsrtms ) + rtB . iosioblynm ; rtB . gtccs23hof = rtB . fs1xewuk02 / rtB . cdp5eufh1x ; rtB . i55gjjxrir = rtX . fqzv5kmfjl ; rtB . ojxua1olai = rtX . mofkaqi0xy ; if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { h3vcrqruvg = rtDW . ewof0menw2 ; rtB . ddyt10yfii = rtP . Gain_Gain * muDoubleScalarCos ( rtDW . ewof0menw2 ) ; } rtB . nspagafdlj = muDoubleScalarCos ( rtB . egfw2eqq25 ) ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtDW . pk4xbzciev = ( rtB . nspagafdlj >= 0.0 ) ; } if ( rtDW . pk4xbzciev > 0 ) { rtB . ncyf4xxbcx = rtB . nspagafdlj ; } else { rtB . ncyf4xxbcx = - rtB . nspagafdlj ; } rtB . em0bromkfe = rtB . ncyf4xxbcx * rtP . x_Value ; rtB . hvzv0eivxd = muDoubleScalarSin ( rtB . egfw2eqq25 ) ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtDW . mxc2whhzeq = ( rtB . hvzv0eivxd >= 0.0 ) ; } if ( rtDW . mxc2whhzeq > 0 ) { rtB . ncffk44u1j = rtB . hvzv0eivxd ; } else { rtB . ncffk44u1j = - rtB . hvzv0eivxd ; } rtB . cw1ewydb0f = rtB . ncffk44u1j * rtP . y_Value ; rtB . pplvipdbqt = rtB . em0bromkfe + rtB . cw1ewydb0f ; rtB . jcplzhdsyu = rtB . ojxua1olai * rtB . pplvipdbqt ; rtB . illbplkffs = rtP . Gain_Gain_p3ka3r0tah * rtB . jcplzhdsyu ; rtDW . aqm5jnhwyz = b030p30edj ; tmp_n = muDoubleScalarCos ( rtB . fmfboyd3ga ) ; tmp_l = muDoubleScalarSin ( rtB . fmfboyd3ga ) ; rtB . hymhyjnp0s = ( ( ( rtB . nf1oadke3r . pxdcpjxbb2 + rtB . fmscqp2pk3 . pxdcpjxbb2 ) + rtB . ddyt10yfii ) + rtB . illbplkffs ) + ( muDoubleScalarSin ( rtB . egfw2eqq25 ) * tmp_n + muDoubleScalarCos ( rtB . egfw2eqq25 ) * tmp_l ) * rtB . lg4f4t2001 ; rtB . gyxxaplaeg = rtB . hymhyjnp0s / rtP . mass_Value ; if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtB . i2c0qloibe = rtP . Windforceinagivendirection_Gain * muDoubleScalarSin ( h3vcrqruvg ) ; } rtB . mg5yjwauwa = muDoubleScalarCos ( rtB . egfw2eqq25 ) ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtDW . f5r30m5mlp = ( rtB . mg5yjwauwa >= 0.0 ) ; } if ( rtDW . f5r30m5mlp > 0 ) { rtB . hotqmhk3kl = rtB . mg5yjwauwa ; } else { rtB . hotqmhk3kl = - rtB . mg5yjwauwa ; } rtB . g4c3l02cmj = rtB . hotqmhk3kl * rtP . DragconstantforxPos_Value ; rtB . bzwsb2hbby = muDoubleScalarSin ( rtB . egfw2eqq25 ) ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtDW . mre1waafup = ( rtB . bzwsb2hbby >= 0.0 ) ; } if ( rtDW . mre1waafup > 0 ) { rtB . esz3cyqdg0 = rtB . bzwsb2hbby ; } else { rtB . esz3cyqdg0 = - rtB . bzwsb2hbby ; } rtB . cfqmztshpv = rtB . esz3cyqdg0 * rtP . DragconstantforyPos_Value ; rtB . pm0s4jhq1e = rtB . g4c3l02cmj + rtB . cfqmztshpv ; rtB . bazqoz24aa = rtB . i55gjjxrir * rtB . pm0s4jhq1e ; rtB . n12cjujndf = rtP . Gain_Gain_mr0cydvft2 * rtB . bazqoz24aa ; rtB . gixculo4s3 = ( ( ( rtB . nf1oadke3r . b5rb2zovck + rtB . fmscqp2pk3 . b5rb2zovck ) + rtB . i2c0qloibe ) + rtB . n12cjujndf ) + ( muDoubleScalarCos ( rtB . egfw2eqq25 ) * tmp_n + - muDoubleScalarSin ( rtB . egfw2eqq25 ) * tmp_l ) * rtB . lg4f4t2001 ; rtB . cgvw14kvhe = rtB . gixculo4s3 / rtP . mass_Value ; rtB . nrytsvdmg0 = rtP . PIDController_I * rtB . f5xxv5c5iw ; rtB . p4g04fwtp3 = rtP . PIDController1_I * rtB . hm1wvbykyh ; rtB . pccpdexwps = rtP . PIDController2_I * rtB . itjs0jtx3o ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtB . cyby0gnkup = rtP . Constant7_Value * rtB . poqfyzkjha ; rtB . prqpzdtaxn = rtP . Constant7_Value * rtB . bpxugea0p4 ; rtB . mtfmpp51ar = rtP . Constant7_Value * rtB . pgjji1gn55 ; } rtB . agudjbqwit [ 0 ] = rtB . cyby0gnkup ; rtB . agudjbqwit [ 1 ] = 0.0 ; rtB . agudjbqwit [ 2 ] = 0.0 ; if ( ssIsMajorTimeStep ( rtS ) ) { rtDW . fqyyafssv0 [ 0 ] = ! ( rtB . agudjbqwit [ 0 ] == rtDW . fqyyafssv0 [ 1 ] ) ; rtDW . fqyyafssv0 [ 1 ] = rtB . agudjbqwit [ 0 ] ; } rtB . agudjbqwit [ 0 ] = rtDW . fqyyafssv0 [ 1 ] ; rtB . agudjbqwit [ 3 ] = rtDW . fqyyafssv0 [ 0 ] ; if ( ( rtDW . nkek3zr1jv != NULL ) && ssGetLogOutput ( rtS ) ) { tmp_c [ 0 ] = rtB . agudjbqwit [ 0 ] ; tmp_c [ 1 ] = rtB . agudjbqwit [ 1 ] ; tmp_c [ 2 ] = rtB . agudjbqwit [ 2 ] ; tmp_c [ 3 ] = rtB . agudjbqwit [ 3 ] ; tmp_c [ 4 ] = rtB . ilgweckhrc [ 0 ] ; tmp_c [ 5 ] = rtB . ilgweckhrc [ 1 ] ; tmp_c [ 6 ] = rtB . ilgweckhrc [ 2 ] ; ssc_rtw_log_fcn ( rtDW . nkek3zr1jv , ssGetT ( rtS ) , & tmp_c [ 0 ] , rtDW . g1mp4mth5z ) ; } if ( ( rtDW . nkek3zr1jv != NULL ) && ssGetLogOutput ( rtS ) ) { ssc_inst_logger_log ( rtDW . hui0e3sc54 , ssGetT ( rtS ) , rtDW . g1mp4mth5z ) ; } rtB . fsw1z0i2v1 [ 0 ] = rtB . prqpzdtaxn ; rtB . fsw1z0i2v1 [ 1 ] = 0.0 ; rtB . fsw1z0i2v1 [ 2 ] = 0.0 ; if ( ssIsMajorTimeStep ( rtS ) ) { rtDW . htt1amrvgv [ 0 ] = ! ( rtB . fsw1z0i2v1 [ 0 ] == rtDW . htt1amrvgv [ 1 ] ) ; rtDW . htt1amrvgv [ 1 ] = rtB . fsw1z0i2v1 [ 0 ] ; } rtB . fsw1z0i2v1 [ 0 ] = rtDW . htt1amrvgv [ 1 ] ; rtB . fsw1z0i2v1 [ 3 ] = rtDW . htt1amrvgv [ 0 ] ; if ( ( rtDW . mfnn1vwzpe != NULL ) && ssGetLogOutput ( rtS ) ) { tmp_k [ 0 ] = rtB . fsw1z0i2v1 [ 0 ] ; tmp_k [ 1 ] = rtB . fsw1z0i2v1 [ 1 ] ; tmp_k [ 2 ] = rtB . fsw1z0i2v1 [ 2 ] ; tmp_k [ 3 ] = rtB . fsw1z0i2v1 [ 3 ] ; tmp_k [ 4 ] = rtB . p3ofdssvna [ 0 ] ; tmp_k [ 5 ] = rtB . p3ofdssvna [ 1 ] ; tmp_k [ 6 ] = rtB . p3ofdssvna [ 2 ] ; ssc_rtw_log_fcn ( rtDW . mfnn1vwzpe , ssGetT ( rtS ) , & tmp_k [ 0 ] , rtDW . gqh21g1lhv ) ; } if ( ( rtDW . mfnn1vwzpe != NULL ) && ssGetLogOutput ( rtS ) ) { ssc_inst_logger_log ( rtDW . hhqju1srnf , ssGetT ( rtS ) , rtDW . gqh21g1lhv ) ; } rtB . ivckfgwj3f [ 0 ] = rtB . mtfmpp51ar ; rtB . ivckfgwj3f [ 1 ] = 0.0 ; rtB . ivckfgwj3f [ 2 ] = 0.0 ; if ( ssIsMajorTimeStep ( rtS ) ) { rtDW . bssgbwzn5f [ 0 ] = ! ( rtB . ivckfgwj3f [ 0 ] == rtDW . bssgbwzn5f [ 1 ] ) ; rtDW . bssgbwzn5f [ 1 ] = rtB . ivckfgwj3f [ 0 ] ; } rtB . ivckfgwj3f [ 0 ] = rtDW . bssgbwzn5f [ 1 ] ; rtB . ivckfgwj3f [ 3 ] = rtDW . bssgbwzn5f [ 0 ] ; if ( ( rtDW . mo5hgh4mup != NULL ) && ssGetLogOutput ( rtS ) ) { tmp_b [ 0 ] = rtB . ivckfgwj3f [ 0 ] ; tmp_b [ 1 ] = rtB . ivckfgwj3f [ 1 ] ; tmp_b [ 2 ] = rtB . ivckfgwj3f [ 2 ] ; tmp_b [ 3 ] = rtB . ivckfgwj3f [ 3 ] ; tmp_b [ 4 ] = rtB . f2ol5xfubh [ 0 ] ; tmp_b [ 5 ] = rtB . f2ol5xfubh [ 1 ] ; tmp_b [ 6 ] = rtB . f2ol5xfubh [ 2 ] ; ssc_rtw_log_fcn ( rtDW . mo5hgh4mup , ssGetT ( rtS ) , & tmp_b [ 0 ] , rtDW . kyjulrp02t ) ; } if ( ( rtDW . mo5hgh4mup != NULL ) && ssGetLogOutput ( rtS ) ) { ssc_inst_logger_log ( rtDW . nuu25nvw2m , ssGetT ( rtS ) , rtDW . kyjulrp02t ) ; } UNUSED_PARAMETER ( tid ) ; } void MdlOutputsTID6 ( int_T tid ) { real_T fjbdtryxmg ; rtB . cdp5eufh1x = ( muDoubleScalarPower ( rtP . lengthoftheboat_Value , rtP . Constant8_Value ) + muDoubleScalarPower ( rtP . Widthoftheboat_Value , rtP . Constant8_Value ) ) * rtP . mass_Value * rtP . Inertiarawconstant_Value ; rtB . fmfboyd3ga = muDoubleScalarAtan2 ( rtP . y_Value_bkb3mktfvw , rtP . x_Value_ekhkiypbtu ) + rtP . Constant_Value ; rtB . aghkd4traa = muDoubleScalarSin ( rtP . Constant_Value ) ; fjbdtryxmg = rtP . x_Value_ekhkiypbtu * rtP . x_Value_ekhkiypbtu + rtP . y_Value_bkb3mktfvw * rtP . y_Value_bkb3mktfvw ; if ( ssIsMajorTimeStep ( rtS ) ) { if ( rtDW . fqcwpuiypl != 0 ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( rtS ) ; rtDW . fqcwpuiypl = 0 ; } rtB . keqzqlqvew = muDoubleScalarSqrt ( fjbdtryxmg ) ; } else if ( fjbdtryxmg < 0.0 ) { rtB . keqzqlqvew = - muDoubleScalarSqrt ( muDoubleScalarAbs ( fjbdtryxmg ) ) ; rtDW . fqcwpuiypl = 1 ; } else { rtB . keqzqlqvew = muDoubleScalarSqrt ( fjbdtryxmg ) ; } rtB . b4feafyt4o = muDoubleScalarAtan2 ( rtP . y_Value_kouoqvqr2q , rtP . x_Value_eq3lkpaxhu ) + rtP . Constant3_Value ; rtB . dn41zbwev0 = muDoubleScalarSin ( rtP . Constant3_Value ) ; fjbdtryxmg = rtP . x_Value_eq3lkpaxhu * rtP . x_Value_eq3lkpaxhu + rtP . y_Value_kouoqvqr2q * rtP . y_Value_kouoqvqr2q ; if ( ssIsMajorTimeStep ( rtS ) ) { if ( rtDW . ilpdoalijh != 0 ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( rtS ) ; rtDW . ilpdoalijh = 0 ; } rtB . if2ghcwui3 = muDoubleScalarSqrt ( fjbdtryxmg ) ; } else if ( fjbdtryxmg < 0.0 ) { rtB . if2ghcwui3 = - muDoubleScalarSqrt ( muDoubleScalarAbs ( fjbdtryxmg ) ) ; rtDW . ilpdoalijh = 1 ; } else { rtB . if2ghcwui3 = muDoubleScalarSqrt ( fjbdtryxmg ) ; } rtB . kizl3igrxr = muDoubleScalarAtan2 ( rtP . y_Value_kwlajmttwi , rtP . x_Value_h2nbl4nm5e ) + rtP . Constant3_Value ; rtB . i3trgao54h = muDoubleScalarSin ( rtP . Constant3_Value ) ; fjbdtryxmg = rtP . x_Value_h2nbl4nm5e * rtP . x_Value_h2nbl4nm5e + rtP . y_Value_kwlajmttwi * rtP . y_Value_kwlajmttwi ; if ( ssIsMajorTimeStep ( rtS ) ) { if ( rtDW . gr1pr4ue0h != 0 ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( rtS ) ; rtDW . gr1pr4ue0h = 0 ; } rtB . n3sn4i2y20 = muDoubleScalarSqrt ( fjbdtryxmg ) ; } else if ( fjbdtryxmg < 0.0 ) { rtB . n3sn4i2y20 = - muDoubleScalarSqrt ( muDoubleScalarAbs ( fjbdtryxmg ) ) ; rtDW . gr1pr4ue0h = 1 ; } else { rtB . n3sn4i2y20 = muDoubleScalarSqrt ( fjbdtryxmg ) ; } UNUSED_PARAMETER ( tid ) ; } void MdlUpdate ( int_T tid ) { NeslSimulationData * simulationData ; NeuDiagnosticManager * diagnosticManager ; NeuDiagnosticTree * diagnosticTree ; NeuDiagnosticTree * diagnosticTree_e ; NeuDiagnosticTree * diagnosticTree_p ; char * msg ; char * msg_e ; char * msg_p ; real_T tmp_j [ 4 ] ; real_T tmp_m [ 4 ] ; real_T tmp_p [ 4 ] ; real_T dc ; real_T time ; real_T time_e ; real_T time_p ; int32_T tmp_i ; int_T tmp_e [ 2 ] ; int_T tmp_f [ 2 ] ; int_T tmp_g [ 2 ] ; boolean_T tmp ; SimStruct * S ; void * diag ; if ( ssIsSampleHit ( rtS , 5 , 0 ) ) { if ( muDoubleScalarIsNaN ( rtB . iuoeijrbuw ) || ( ( rtB . iuoeijrbuw == ( rtInf ) ) || ( rtB . iuoeijrbuw == ( rtMinusInf ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputDutyCycleForVPG" , 3 , 3 , "boat/PWM/Variable Pulse Generator" , 2 , rtB . iuoeijrbuw , 2 , ssGetTaskTime ( rtS , 5 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( rtDW . ozkuq5jrkw ) { dc = rtB . iuoeijrbuw ; if ( ( rtP . PWM_Period <= 0.0 ) || ( muDoubleScalarIsNaN ( rtP . PWM_Period ) || ( ( rtP . PWM_Period == ( rtInf ) ) || ( rtP . PWM_Period == ( rtMinusInf ) ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputPeriodForVPG" , 3 , 3 , "boat/PWM/Variable Pulse Generator" , 2 , rtP . PWM_Period , 2 , ssGetTaskTime ( rtS , 1 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( dc * rtP . PWM_Period + ssGetTaskTime ( rtS , 1 ) <= 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 1 ) + ssGetTaskTime ( rtS , 1 ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvPulseWidthForVPG" , 5 , 3 , "boat/PWM/Variable Pulse Generator" , 2 , rtB . iuoeijrbuw , 2 , rtP . PWM_Period , 2 , ssGetTaskTime ( rtS , 1 ) , 2 , 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 1 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( dc > 1.0 ) { dc = 1.0 ; if ( rtDW . pozaiatm4a ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:warnDutyCycleGreaterThanOne" , 3 , 2 , ssGetTaskTime ( rtS , 1 ) , 2 , rtB . iuoeijrbuw , 3 , "boat/PWM/Variable Pulse Generator" ) ; rt_ssReportDiagnosticAsWarning ( S , diag ) ; rtDW . pozaiatm4a = false ; } } else if ( 1.0 - rtB . iuoeijrbuw < 2.8421709430404007E-14 ) { dc = 1.0 ; } if ( ( rtDW . megpocnlzf > 0.0 ) && ( rtDW . megpocnlzf == rtP . PWM_Period ) ) { rtDW . l1c0vzua01 ++ ; } else { rtDW . l1c0vzua01 = 1ULL ; rtDW . megpocnlzf = rtP . PWM_Period ; rtDW . jj4ax1istk = ssGetTaskTime ( rtS , 1 ) ; } rtDW . evor0o0u1w = rtDW . megpocnlzf * ( real_T ) rtDW . l1c0vzua01 + rtDW . jj4ax1istk ; if ( rtDW . evor0o0u1w - ( dc * rtP . PWM_Period + ssGetTaskTime ( rtS , 1 ) ) > rtDW . evor0o0u1w * 2.8421709430404007E-14 ) { _ssSetVarNextHitTime ( rtS , 2 , ssGetTaskTime ( rtS , 1 ) + dc * rtP . PWM_Period ) ; rtDW . ozkuq5jrkw = false ; rtDW . n52coetlf4 = false ; } else { _ssSetVarNextHitTime ( rtS , 2 , rtDW . evor0o0u1w ) ; rtDW . ozkuq5jrkw = true ; rtDW . n52coetlf4 = true ; } } else { if ( rtDW . n52coetlf4 ) { if ( ( rtP . PWM_Period <= 0.0 ) || ( muDoubleScalarIsNaN ( rtP . PWM_Period ) || ( ( rtP . PWM_Period == ( rtInf ) ) || ( rtP . PWM_Period == ( rtMinusInf ) ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputPeriodForVPG" , 3 , 3 , "boat/PWM/Variable Pulse Generator" , 2 , rtP . PWM_Period , 2 , ssGetTaskTime ( rtS , 1 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( ( rtB . iuoeijrbuw < 0.0 ) && rtDW . gf4ksr2aha ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:warnDutyCycleLessThanZero" , 3 , 2 , ssGetTaskTime ( rtS , 1 ) , 2 , rtB . iuoeijrbuw , 3 , "boat/PWM/Variable Pulse Generator" ) ; rt_ssReportDiagnosticAsWarning ( S , diag ) ; rtDW . gf4ksr2aha = false ; } if ( ( rtDW . megpocnlzf > 0.0 ) && ( rtDW . megpocnlzf == rtP . PWM_Period ) ) { rtDW . l1c0vzua01 ++ ; } else { rtDW . l1c0vzua01 = 1ULL ; rtDW . megpocnlzf = rtP . PWM_Period ; rtDW . jj4ax1istk = ssGetTaskTime ( rtS , 1 ) ; } _ssSetVarNextHitTime ( rtS , 2 , ssGetTaskTime ( rtS , 1 ) + rtP . PWM_Period ) ; } else if ( rtDW . evor0o0u1w > 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 1 ) + ssGetTaskTime ( rtS , 1 ) ) { _ssSetVarNextHitTime ( rtS , 2 , rtDW . evor0o0u1w ) ; } rtDW . ozkuq5jrkw = true ; rtDW . n52coetlf4 = true ; } } if ( ssIsSampleHit ( rtS , 3 , 0 ) ) { if ( muDoubleScalarIsNaN ( rtB . lerfsdmwkn ) || ( ( rtB . lerfsdmwkn == ( rtInf ) ) || ( rtB . lerfsdmwkn == ( rtMinusInf ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputDutyCycleForVPG" , 3 , 3 , "boat/PWM1/Variable Pulse Generator" , 2 , rtB . lerfsdmwkn , 2 , ssGetTaskTime ( rtS , 3 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( rtDW . fgliutlg4v ) { dc = rtB . lerfsdmwkn ; if ( ( rtP . PWM1_Period <= 0.0 ) || ( muDoubleScalarIsNaN ( rtP . PWM1_Period ) || ( ( rtP . PWM1_Period == ( rtInf ) ) || ( rtP . PWM1_Period == ( rtMinusInf ) ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputPeriodForVPG" , 3 , 3 , "boat/PWM1/Variable Pulse Generator" , 2 , rtP . PWM1_Period , 2 , ssGetTaskTime ( rtS , 1 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( dc * rtP . PWM1_Period + ssGetTaskTime ( rtS , 1 ) <= 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 1 ) + ssGetTaskTime ( rtS , 1 ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvPulseWidthForVPG" , 5 , 3 , "boat/PWM1/Variable Pulse Generator" , 2 , rtB . lerfsdmwkn , 2 , rtP . PWM1_Period , 2 , ssGetTaskTime ( rtS , 1 ) , 2 , 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 1 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( dc > 1.0 ) { dc = 1.0 ; if ( rtDW . krmutnbn45 ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:warnDutyCycleGreaterThanOne" , 3 , 2 , ssGetTaskTime ( rtS , 1 ) , 2 , rtB . lerfsdmwkn , 3 , "boat/PWM1/Variable Pulse Generator" ) ; rt_ssReportDiagnosticAsWarning ( S , diag ) ; rtDW . krmutnbn45 = false ; } } else if ( 1.0 - rtB . lerfsdmwkn < 2.8421709430404007E-14 ) { dc = 1.0 ; } if ( ( rtDW . doojhifyms > 0.0 ) && ( rtDW . doojhifyms == rtP . PWM1_Period ) ) { rtDW . j1zvgotszs ++ ; } else { rtDW . j1zvgotszs = 1ULL ; rtDW . doojhifyms = rtP . PWM1_Period ; rtDW . ifeym0p3d4 = ssGetTaskTime ( rtS , 1 ) ; } rtDW . cq4fy31po1 = rtDW . doojhifyms * ( real_T ) rtDW . j1zvgotszs + rtDW . ifeym0p3d4 ; if ( rtDW . cq4fy31po1 - ( dc * rtP . PWM1_Period + ssGetTaskTime ( rtS , 1 ) ) > rtDW . cq4fy31po1 * 2.8421709430404007E-14 ) { _ssSetVarNextHitTime ( rtS , 0 , ssGetTaskTime ( rtS , 1 ) + dc * rtP . PWM1_Period ) ; rtDW . fgliutlg4v = false ; rtDW . gbzgjra1qd = false ; } else { _ssSetVarNextHitTime ( rtS , 0 , rtDW . cq4fy31po1 ) ; rtDW . fgliutlg4v = true ; rtDW . gbzgjra1qd = true ; } } else { if ( rtDW . gbzgjra1qd ) { if ( ( rtP . PWM1_Period <= 0.0 ) || ( muDoubleScalarIsNaN ( rtP . PWM1_Period ) || ( ( rtP . PWM1_Period == ( rtInf ) ) || ( rtP . PWM1_Period == ( rtMinusInf ) ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputPeriodForVPG" , 3 , 3 , "boat/PWM1/Variable Pulse Generator" , 2 , rtP . PWM1_Period , 2 , ssGetTaskTime ( rtS , 1 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( ( rtB . lerfsdmwkn < 0.0 ) && rtDW . njxj2gqdqb ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:warnDutyCycleLessThanZero" , 3 , 2 , ssGetTaskTime ( rtS , 1 ) , 2 , rtB . lerfsdmwkn , 3 , "boat/PWM1/Variable Pulse Generator" ) ; rt_ssReportDiagnosticAsWarning ( S , diag ) ; rtDW . njxj2gqdqb = false ; } if ( ( rtDW . doojhifyms > 0.0 ) && ( rtDW . doojhifyms == rtP . PWM1_Period ) ) { rtDW . j1zvgotszs ++ ; } else { rtDW . j1zvgotszs = 1ULL ; rtDW . doojhifyms = rtP . PWM1_Period ; rtDW . ifeym0p3d4 = ssGetTaskTime ( rtS , 1 ) ; } _ssSetVarNextHitTime ( rtS , 0 , ssGetTaskTime ( rtS , 1 ) + rtP . PWM1_Period ) ; } else if ( rtDW . cq4fy31po1 > 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 1 ) + ssGetTaskTime ( rtS , 1 ) ) { _ssSetVarNextHitTime ( rtS , 0 , rtDW . cq4fy31po1 ) ; } rtDW . fgliutlg4v = true ; rtDW . gbzgjra1qd = true ; } } if ( ssIsSampleHit ( rtS , 4 , 0 ) ) { if ( muDoubleScalarIsNaN ( rtB . aucpl4jwuv ) || ( ( rtB . aucpl4jwuv == ( rtInf ) ) || ( rtB . aucpl4jwuv == ( rtMinusInf ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputDutyCycleForVPG" , 3 , 3 , "boat/PWM2/Variable Pulse Generator" , 2 , rtB . aucpl4jwuv , 2 , ssGetTaskTime ( rtS , 4 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( rtDW . kdmfiti23w ) { dc = rtB . aucpl4jwuv ; if ( ( rtP . PWM2_Period <= 0.0 ) || ( muDoubleScalarIsNaN ( rtP . PWM2_Period ) || ( ( rtP . PWM2_Period == ( rtInf ) ) || ( rtP . PWM2_Period == ( rtMinusInf ) ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputPeriodForVPG" , 3 , 3 , "boat/PWM2/Variable Pulse Generator" , 2 , rtP . PWM2_Period , 2 , ssGetTaskTime ( rtS , 1 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( dc * rtP . PWM2_Period + ssGetTaskTime ( rtS , 1 ) <= 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 1 ) + ssGetTaskTime ( rtS , 1 ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvPulseWidthForVPG" , 5 , 3 , "boat/PWM2/Variable Pulse Generator" , 2 , rtB . aucpl4jwuv , 2 , rtP . PWM2_Period , 2 , ssGetTaskTime ( rtS , 1 ) , 2 , 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 1 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( dc > 1.0 ) { dc = 1.0 ; if ( rtDW . myaevvlju4 ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:warnDutyCycleGreaterThanOne" , 3 , 2 , ssGetTaskTime ( rtS , 1 ) , 2 , rtB . aucpl4jwuv , 3 , "boat/PWM2/Variable Pulse Generator" ) ; rt_ssReportDiagnosticAsWarning ( S , diag ) ; rtDW . myaevvlju4 = false ; } } else if ( 1.0 - rtB . aucpl4jwuv < 2.8421709430404007E-14 ) { dc = 1.0 ; } if ( ( rtDW . habwkca01a > 0.0 ) && ( rtDW . habwkca01a == rtP . PWM2_Period ) ) { rtDW . oktrhzldpx ++ ; } else { rtDW . oktrhzldpx = 1ULL ; rtDW . habwkca01a = rtP . PWM2_Period ; rtDW . and0otfyv2 = ssGetTaskTime ( rtS , 1 ) ; } rtDW . ik3uudsjyg = rtDW . habwkca01a * ( real_T ) rtDW . oktrhzldpx + rtDW . and0otfyv2 ; if ( rtDW . ik3uudsjyg - ( dc * rtP . PWM2_Period + ssGetTaskTime ( rtS , 1 ) ) > rtDW . ik3uudsjyg * 2.8421709430404007E-14 ) { _ssSetVarNextHitTime ( rtS , 1 , ssGetTaskTime ( rtS , 1 ) + dc * rtP . PWM2_Period ) ; rtDW . kdmfiti23w = false ; rtDW . phgeenzoik = false ; } else { _ssSetVarNextHitTime ( rtS , 1 , rtDW . ik3uudsjyg ) ; rtDW . kdmfiti23w = true ; rtDW . phgeenzoik = true ; } } else { if ( rtDW . phgeenzoik ) { if ( ( rtP . PWM2_Period <= 0.0 ) || ( muDoubleScalarIsNaN ( rtP . PWM2_Period ) || ( ( rtP . PWM2_Period == ( rtInf ) ) || ( rtP . PWM2_Period == ( rtMinusInf ) ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputPeriodForVPG" , 3 , 3 , "boat/PWM2/Variable Pulse Generator" , 2 , rtP . PWM2_Period , 2 , ssGetTaskTime ( rtS , 1 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( ( rtB . aucpl4jwuv < 0.0 ) && rtDW . m405qgdu1y ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:warnDutyCycleLessThanZero" , 3 , 2 , ssGetTaskTime ( rtS , 1 ) , 2 , rtB . aucpl4jwuv , 3 , "boat/PWM2/Variable Pulse Generator" ) ; rt_ssReportDiagnosticAsWarning ( S , diag ) ; rtDW . m405qgdu1y = false ; } if ( ( rtDW . habwkca01a > 0.0 ) && ( rtDW . habwkca01a == rtP . PWM2_Period ) ) { rtDW . oktrhzldpx ++ ; } else { rtDW . oktrhzldpx = 1ULL ; rtDW . habwkca01a = rtP . PWM2_Period ; rtDW . and0otfyv2 = ssGetTaskTime ( rtS , 1 ) ; } _ssSetVarNextHitTime ( rtS , 1 , ssGetTaskTime ( rtS , 1 ) + rtP . PWM2_Period ) ; } else if ( rtDW . ik3uudsjyg > 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 1 ) + ssGetTaskTime ( rtS , 1 ) ) { _ssSetVarNextHitTime ( rtS , 1 , rtDW . ik3uudsjyg ) ; } rtDW . kdmfiti23w = true ; rtDW . phgeenzoik = true ; } } if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtDW . k4wpb4vucr = rt_nrand_Upu32_Yd_f_pw_snf ( & rtDW . lndskdfmom ) * rtP . WhiteNoise_StdDev + rtP . WhiteNoise_Mean ; } simulationData = ( NeslSimulationData * ) rtDW . matviv3tsc ; time = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time ; simulationData -> mData -> mContStates . mN = 3 ; simulationData -> mData -> mContStates . mX = & rtX . cbt50efduc [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 0 ; simulationData -> mData -> mDiscStates . mX = & rtDW . m5zbqevzsx ; simulationData -> mData -> mModeVector . mN = 0 ; simulationData -> mData -> mModeVector . mX = & rtDW . hgyea5eklz ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_e [ 0 ] = 0 ; tmp_p [ 0 ] = rtB . fsw1z0i2v1 [ 0 ] ; tmp_p [ 1 ] = rtB . fsw1z0i2v1 [ 1 ] ; tmp_p [ 2 ] = rtB . fsw1z0i2v1 [ 2 ] ; tmp_p [ 3 ] = rtB . fsw1z0i2v1 [ 3 ] ; tmp_e [ 1 ] = 4 ; simulationData -> mData -> mInputValues . mN = 4 ; simulationData -> mData -> mInputValues . mX = & tmp_p [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 2 ; simulationData -> mData -> mInputOffsets . mX = & tmp_e [ 0 ] ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . ncn0gprufm ; diagnosticTree = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = ne_simulator_method ( ( NeslSimulator * ) rtDW . nzbcd4gsn0 , NESL_SIM_UPDATE , simulationData , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg = rtw_diagnostics_msg ( diagnosticTree ) ; ssSetErrorStatus ( rtS , msg ) ; } } simulationData = ( NeslSimulationData * ) rtDW . mdrfbzfj35 ; time_p = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_p ; simulationData -> mData -> mContStates . mN = 3 ; simulationData -> mData -> mContStates . mX = & rtX . fbrr2x2skx [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 0 ; simulationData -> mData -> mDiscStates . mX = & rtDW . idc5s0rsfa ; simulationData -> mData -> mModeVector . mN = 0 ; simulationData -> mData -> mModeVector . mX = & rtDW . gsaeaqfztj ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_g [ 0 ] = 0 ; tmp_m [ 0 ] = rtB . agudjbqwit [ 0 ] ; tmp_m [ 1 ] = rtB . agudjbqwit [ 1 ] ; tmp_m [ 2 ] = rtB . agudjbqwit [ 2 ] ; tmp_m [ 3 ] = rtB . agudjbqwit [ 3 ] ; tmp_g [ 1 ] = 4 ; simulationData -> mData -> mInputValues . mN = 4 ; simulationData -> mData -> mInputValues . mX = & tmp_m [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 2 ; simulationData -> mData -> mInputOffsets . mX = & tmp_g [ 0 ] ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . o3nzm0dbcw ; diagnosticTree_p = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = ne_simulator_method ( ( NeslSimulator * ) rtDW . brvpxkjfg4 , NESL_SIM_UPDATE , simulationData , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg_p = rtw_diagnostics_msg ( diagnosticTree_p ) ; ssSetErrorStatus ( rtS , msg_p ) ; } } simulationData = ( NeslSimulationData * ) rtDW . eg2dr13w4n ; time_e = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_e ; simulationData -> mData -> mContStates . mN = 3 ; simulationData -> mData -> mContStates . mX = & rtX . mqsayiekhp [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 0 ; simulationData -> mData -> mDiscStates . mX = & rtDW . oq4y10dztc ; simulationData -> mData -> mModeVector . mN = 0 ; simulationData -> mData -> mModeVector . mX = & rtDW . bfxht5ivew ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_f [ 0 ] = 0 ; tmp_j [ 0 ] = rtB . ivckfgwj3f [ 0 ] ; tmp_j [ 1 ] = rtB . ivckfgwj3f [ 1 ] ; tmp_j [ 2 ] = rtB . ivckfgwj3f [ 2 ] ; tmp_j [ 3 ] = rtB . ivckfgwj3f [ 3 ] ; tmp_f [ 1 ] = 4 ; simulationData -> mData -> mInputValues . mN = 4 ; simulationData -> mData -> mInputValues . mX = & tmp_j [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 2 ; simulationData -> mData -> mInputOffsets . mX = & tmp_f [ 0 ] ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . deu0nhli3p ; diagnosticTree_e = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = ne_simulator_method ( ( NeslSimulator * ) rtDW . b4ovldmiyf , NESL_SIM_UPDATE , simulationData , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg_e = rtw_diagnostics_msg ( diagnosticTree_e ) ; ssSetErrorStatus ( rtS , msg_e ) ; } } if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtDW . k1sbpk4k2l = ( rtP . UniformRandomNumber1_Maximum - rtP . UniformRandomNumber1_Minimum ) * rt_urand_Upu32_Yd_f_pw_snf ( & rtDW . iur0xot0u0 ) + rtP . UniformRandomNumber1_Minimum ; rtDW . ewof0menw2 = ( rtP . UniformRandomNumber_Maximum - rtP . UniformRandomNumber_Minimum ) * rt_urand_Upu32_Yd_f_pw_snf ( & rtDW . hwgvqn3aty ) + rtP . UniformRandomNumber_Minimum ; } UNUSED_PARAMETER ( tid ) ; } void MdlUpdateTID6 ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlDerivatives ( void ) { XDot * _rtXdot ; _rtXdot = ( ( XDot * ) ssGetdX ( rtS ) ) ; _rtXdot -> f2d4l4jl4s = rtB . i55gjjxrir ; _rtXdot -> eqm01ekw05 = rtB . ojxua1olai ; _rtXdot -> llcy0vep2l = rtB . dtgw2eazth ; _rtXdot -> kv3akytruj = rtB . nrytsvdmg0 ; _rtXdot -> ecyoj2i3gw = rtB . ckxmfogvuu ; _rtXdot -> g13n4kjtrj = rtB . p4g04fwtp3 ; _rtXdot -> bgucvxka1s = rtB . ny5ud0kux2 ; _rtXdot -> lgrsqc5d1d = rtB . pccpdexwps ; _rtXdot -> fmj0130ch2 = rtB . mm1pucs154 ; _rtXdot -> cbt50efduc [ 0 ] = - 0.010000000000009454 * rtX . cbt50efduc [ 0 ] ; _rtXdot -> cbt50efduc [ 1 ] = - 2.2918311803514055 * rtX . cbt50efduc [ 0 ] ; _rtXdot -> cbt50efduc [ 2 ] = rtX . cbt50efduc [ 0 ] ; _rtXdot -> cbt50efduc [ 0 ] += 0.013750987082108432 * rtX . cbt50efduc [ 1 ] ; _rtXdot -> cbt50efduc [ 1 ] += - 249.99999998125 * rtX . cbt50efduc [ 1 ] ; _rtXdot -> cbt50efduc [ 0 ] += 1.375098708210843E-11 * rtB . fsw1z0i2v1 [ 0 ] ; _rtXdot -> cbt50efduc [ 1 ] += 3333.3333330833334 * rtB . fsw1z0i2v1 [ 0 ] ; _rtXdot -> fbrr2x2skx [ 0 ] = - 249.99999998125 * rtX . fbrr2x2skx [ 0 ] ; _rtXdot -> fbrr2x2skx [ 1 ] = 0.013750987082108432 * rtX . fbrr2x2skx [ 0 ] ; _rtXdot -> fbrr2x2skx [ 0 ] += - 2.2918311803514055 * rtX . fbrr2x2skx [ 1 ] ; _rtXdot -> fbrr2x2skx [ 1 ] += - 0.010000000000009454 * rtX . fbrr2x2skx [ 1 ] ; _rtXdot -> fbrr2x2skx [ 2 ] = rtX . fbrr2x2skx [ 1 ] ; _rtXdot -> fbrr2x2skx [ 0 ] += 3333.3333330833334 * rtB . agudjbqwit [ 0 ] ; _rtXdot -> fbrr2x2skx [ 1 ] += 1.375098708210843E-11 * rtB . agudjbqwit [ 0 ] ; _rtXdot -> mqsayiekhp [ 0 ] = - 0.16688665033792752 * rtX . mqsayiekhp [ 0 ] ; _rtXdot -> mqsayiekhp [ 1 ] = 93.395540156503515 * rtX . mqsayiekhp [ 0 ] ; _rtXdot -> mqsayiekhp [ 0 ] += - 6.5115617557475449 * rtX . mqsayiekhp [ 1 ] ; _rtXdot -> mqsayiekhp [ 1 ] += - 0.010000436136346109 * rtX . mqsayiekhp [ 1 ] ; _rtXdot -> mqsayiekhp [ 2 ] = rtX . mqsayiekhp [ 1 ] ; _rtXdot -> mqsayiekhp [ 0 ] += 1.3944052883160707 * rtB . ivckfgwj3f [ 0 ] ; _rtXdot -> mqsayiekhp [ 1 ] += 9.3395540156503522E-8 * rtB . ivckfgwj3f [ 0 ] ; _rtXdot -> de235fb3n0 = rtB . gtccs23hof ; _rtXdot -> fqzv5kmfjl = rtB . cgvw14kvhe ; _rtXdot -> mofkaqi0xy = rtB . gyxxaplaeg ; _rtXdot -> ds1lkir2ik = rtP . Constant1_Value ; } void MdlProjection ( void ) { } void MdlZeroCrossings ( void ) { ZCV * _rtZCSV ; _rtZCSV = ( ( ZCV * ) ssGetSolverZcSignalVector ( rtS ) ) ; _rtZCSV -> lk1x0wb3uw = rtB . jsslo5nqyh ; _rtZCSV -> avdgmodhdp = rtB . a44cutexgr ; _rtZCSV -> gq4uivdc23 = rtB . a4iypm4gbs ; _rtZCSV -> b1dr4gie5t = rtB . a3vetqfkld - rtP . Dutycyclelimit003_UpperSat ; _rtZCSV -> e4ufwo5o3v = rtB . a3vetqfkld - rtP . Dutycyclelimit003_LowerSat ; _rtZCSV -> bsryt4txye = rtB . objm10tupt - rtP . Dutycyclelimit001_UpperSat ; _rtZCSV -> ifdmkr3knb = rtB . objm10tupt - rtP . Dutycyclelimit001_LowerSat ; _rtZCSV -> gbspzhrqlg = rtB . iokldrmvxg - rtP . Dutycyclelimit002_UpperSat ; _rtZCSV -> pqsoo1oaxp = rtB . iokldrmvxg - rtP . Dutycyclelimit002_LowerSat ; _rtZCSV -> foq2mns1xd = rtB . nspagafdlj ; _rtZCSV -> kz5wktlnvd = rtB . hvzv0eivxd ; _rtZCSV -> caczzs3usb = rtB . mg5yjwauwa ; _rtZCSV -> gtx33htujt = rtB . bzwsb2hbby ; } void MdlTerminate ( void ) { neu_destroy_diagnostic_manager ( ( NeuDiagnosticManager * ) rtDW . ncn0gprufm ) ; nesl_destroy_simulation_data ( ( NeslSimulationData * ) rtDW . matviv3tsc ) ; nesl_erase_simulator ( "boat/Solver Configuration1_1" ) ; nesl_destroy_registry ( ) ; neu_destroy_diagnostic_manager ( ( NeuDiagnosticManager * ) rtDW . o3nzm0dbcw ) ; nesl_destroy_simulation_data ( ( NeslSimulationData * ) rtDW . mdrfbzfj35 ) ; nesl_erase_simulator ( "boat/Solver Configuration_1" ) ; nesl_destroy_registry ( ) ; neu_destroy_diagnostic_manager ( ( NeuDiagnosticManager * ) rtDW . deu0nhli3p ) ; nesl_destroy_simulation_data ( ( NeslSimulationData * ) rtDW . eg2dr13w4n ) ; nesl_erase_simulator ( "boat/Solver Configuration2_1" ) ; nesl_destroy_registry ( ) ; ssc_inst_logger_terminate ( rtDW . hui0e3sc54 ) ; free ( rtDW . g1mp4mth5z ) ; ssc_inst_logger_destroy ( rtDW . hui0e3sc54 ) ; ssc_inst_logger_terminate ( rtDW . hhqju1srnf ) ; free ( rtDW . gqh21g1lhv ) ; ssc_inst_logger_destroy ( rtDW . hhqju1srnf ) ; ssc_inst_logger_terminate ( rtDW . nuu25nvw2m ) ; free ( rtDW . kyjulrp02t ) ; ssc_inst_logger_destroy ( rtDW . nuu25nvw2m ) ; } static void mr_boat_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) ; static void mr_boat_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) { mxArray * newArray = mxCreateUninitNumericMatrix ( ( size_t ) 1 , numBytes , mxUINT8_CLASS , mxREAL ) ; memcpy ( ( uint8_T * ) mxGetData ( newArray ) , ( const uint8_T * ) srcData , numBytes ) ; mxSetFieldByNumber ( destArray , i , j , newArray ) ; } static void mr_boat_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) ; static void mr_boat_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) { memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) , numBytes ) ; } static void mr_boat_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) ; static void mr_boat_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) { mxSetFieldByNumber ( destArray , i , j , mxCreateDoubleScalar ( ( real_T ) bitVal ) ) ; } static uint_T mr_boat_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) ; static uint_T mr_boat_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) { const uint_T varVal = ( uint_T ) mxGetScalar ( mxGetFieldByNumber ( srcArray , i , j ) ) ; return varVal & ( ( 1u << numBits ) - 1u ) ; } static void mr_boat_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) ; static void mr_boat_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) { uint8_T * varData = ( uint8_T * ) mxGetData ( mxGetFieldByNumber ( destArray , i , j ) ) ; memcpy ( ( uint8_T * ) & varData [ offset * numBytes ] , ( const uint8_T * ) srcData , numBytes ) ; } static void mr_boat_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) ; static void mr_boat_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) { const uint8_T * varData = ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) ; memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) & varData [ offset * numBytes ] , numBytes ) ; } static void mr_boat_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) ; static void mr_boat_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) { mxSetCell ( mxGetFieldByNumber ( destArray , i , j ) , offset , mxCreateDoubleScalar ( ( real_T ) fieldVal ) ) ; } static uint_T mr_boat_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) ; static uint_T mr_boat_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) { const uint_T fieldVal = ( uint_T ) mxGetScalar ( mxGetCell ( mxGetFieldByNumber ( srcArray , i , j ) , offset ) ) ; return fieldVal & ( ( 1u << numBits ) - 1u ) ; } mxArray * mr_boat_GetDWork ( ) { static const char_T * ssDWFieldNames [ 3 ] = { "rtB" , "rtDW" , "NULL_PrevZCX" , } ; mxArray * ssDW = mxCreateStructMatrix ( 1 , 1 , 3 , ssDWFieldNames ) ; mr_boat_cacheDataAsMxArray ( ssDW , 0 , 0 , ( const void * ) & ( rtB ) , sizeof ( rtB ) ) ; { static const char_T * rtdwDataFieldNames [ 92 ] = { "rtDW.fqyyafssv0" , "rtDW.htt1amrvgv" , "rtDW.bssgbwzn5f" , "rtDW.evor0o0u1w" , "rtDW.jj4ax1istk" , "rtDW.megpocnlzf" , "rtDW.cq4fy31po1" , "rtDW.ifeym0p3d4" , "rtDW.doojhifyms" , "rtDW.ik3uudsjyg" , "rtDW.and0otfyv2" , "rtDW.habwkca01a" , "rtDW.k4wpb4vucr" , "rtDW.m5zbqevzsx" , "rtDW.b5owcqllef" , "rtDW.ihfadbhak5" , "rtDW.f2qgyziyrt" , "rtDW.idc5s0rsfa" , "rtDW.ev3nsxizqu" , "rtDW.ks3ujawclj" , "rtDW.cqweur5z4o" , "rtDW.oq4y10dztc" , "rtDW.hxbifjq51u" , "rtDW.gc5xhbklnl" , "rtDW.cxcc0o32ih" , "rtDW.k1sbpk4k2l" , "rtDW.ewof0menw2" , "rtDW.l1c0vzua01" , "rtDW.j1zvgotszs" , "rtDW.oktrhzldpx" , "rtDW.aqm5jnhwyz" , "rtDW.lndskdfmom" , "rtDW.iur0xot0u0" , "rtDW.hwgvqn3aty" , "rtDW.hgyea5eklz" , "rtDW.ic10kvv3vn" , "rtDW.gsaeaqfztj" , "rtDW.pswit010me" , "rtDW.bfxht5ivew" , "rtDW.dzo1rnylqc" , "rtDW.nnoau3gejb" , "rtDW.bexc5hutlj" , "rtDW.hq42bs4esx" , "rtDW.cr5oo1xudj" , "rtDW.akw4wluyho" , "rtDW.ks031m0ijp" , "rtDW.pk4xbzciev" , "rtDW.mxc2whhzeq" , "rtDW.f5r30m5mlp" , "rtDW.mre1waafup" , "rtDW.fqcwpuiypl" , "rtDW.ilpdoalijh" , "rtDW.gr1pr4ue0h" , "rtDW.jdajwtteu1" , "rtDW.bsktzayyjw" , "rtDW.ndrbsa54bo" , "rtDW.fseioyxtld" , "rtDW.lamh4epvtt" , "rtDW.a5s15vizq1" , "rtDW.lwcgqnzxxh" , "rtDW.nbymm4zf0e" , "rtDW.akl20qtgvf" , "rtDW.cg5p3fc1vb" , "rtDW.c2zvhsobgq" , "rtDW.ce4ngnm0vz" , "rtDW.ozkuq5jrkw" , "rtDW.n52coetlf4" , "rtDW.pozaiatm4a" , "rtDW.gf4ksr2aha" , "rtDW.fgliutlg4v" , "rtDW.gbzgjra1qd" , "rtDW.krmutnbn45" , "rtDW.njxj2gqdqb" , "rtDW.kdmfiti23w" , "rtDW.phgeenzoik" , "rtDW.myaevvlju4" , "rtDW.m405qgdu1y" , "rtDW.nmot3ctkc4" , "rtDW.hihjm3wgc4" , "rtDW.gb30213u1q" , "rtDW.eamuase24a" , "rtDW.aen5lyyfuu" , "rtDW.eeglzokwfe" , "rtDW.ihhztqiixf" , "rtDW.fmscqp2pk3.ajgetwghvc" , "rtDW.fmscqp2pk3.mbrn4fhlwd" , "rtDW.nf1oadke3r.ajgetwghvc" , "rtDW.nf1oadke3r.mbrn4fhlwd" , "rtDW.hbgiv4wxgq.cxxrtrw5jz" , "rtDW.hbgiv4wxgq.bhv4aykvhq" , "rtDW.ifmn2jhohh.cxxrtrw5jz" , "rtDW.ifmn2jhohh.bhv4aykvhq" , } ; mxArray * rtdwData = mxCreateStructMatrix ( 1 , 1 , 92 , rtdwDataFieldNames ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 0 , ( const void * ) & ( rtDW . fqyyafssv0 ) , sizeof ( rtDW . fqyyafssv0 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 1 , ( const void * ) & ( rtDW . htt1amrvgv ) , sizeof ( rtDW . htt1amrvgv ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 2 , ( const void * ) & ( rtDW . bssgbwzn5f ) , sizeof ( rtDW . bssgbwzn5f ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 3 , ( const void * ) & ( rtDW . evor0o0u1w ) , sizeof ( rtDW . evor0o0u1w ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 4 , ( const void * ) & ( rtDW . jj4ax1istk ) , sizeof ( rtDW . jj4ax1istk ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 5 , ( const void * ) & ( rtDW . megpocnlzf ) , sizeof ( rtDW . megpocnlzf ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 6 , ( const void * ) & ( rtDW . cq4fy31po1 ) , sizeof ( rtDW . cq4fy31po1 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 7 , ( const void * ) & ( rtDW . ifeym0p3d4 ) , sizeof ( rtDW . ifeym0p3d4 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 8 , ( const void * ) & ( rtDW . doojhifyms ) , sizeof ( rtDW . doojhifyms ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 9 , ( const void * ) & ( rtDW . ik3uudsjyg ) , sizeof ( rtDW . ik3uudsjyg ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 10 , ( const void * ) & ( rtDW . and0otfyv2 ) , sizeof ( rtDW . and0otfyv2 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 11 , ( const void * ) & ( rtDW . habwkca01a ) , sizeof ( rtDW . habwkca01a ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 12 , ( const void * ) & ( rtDW . k4wpb4vucr ) , sizeof ( rtDW . k4wpb4vucr ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 13 , ( const void * ) & ( rtDW . m5zbqevzsx ) , sizeof ( rtDW . m5zbqevzsx ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 14 , ( const void * ) & ( rtDW . b5owcqllef ) , sizeof ( rtDW . b5owcqllef ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 15 , ( const void * ) & ( rtDW . ihfadbhak5 ) , sizeof ( rtDW . ihfadbhak5 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 16 , ( const void * ) & ( rtDW . f2qgyziyrt ) , sizeof ( rtDW . f2qgyziyrt ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 17 , ( const void * ) & ( rtDW . idc5s0rsfa ) , sizeof ( rtDW . idc5s0rsfa ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 18 , ( const void * ) & ( rtDW . ev3nsxizqu ) , sizeof ( rtDW . ev3nsxizqu ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 19 , ( const void * ) & ( rtDW . ks3ujawclj ) , sizeof ( rtDW . ks3ujawclj ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 20 , ( const void * ) & ( rtDW . cqweur5z4o ) , sizeof ( rtDW . cqweur5z4o ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 21 , ( const void * ) & ( rtDW . oq4y10dztc ) , sizeof ( rtDW . oq4y10dztc ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 22 , ( const void * ) & ( rtDW . hxbifjq51u ) , sizeof ( rtDW . hxbifjq51u ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 23 , ( const void * ) & ( rtDW . gc5xhbklnl ) , sizeof ( rtDW . gc5xhbklnl ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 24 , ( const void * ) & ( rtDW . cxcc0o32ih ) , sizeof ( rtDW . cxcc0o32ih ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 25 , ( const void * ) & ( rtDW . k1sbpk4k2l ) , sizeof ( rtDW . k1sbpk4k2l ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 26 , ( const void * ) & ( rtDW . ewof0menw2 ) , sizeof ( rtDW . ewof0menw2 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 27 , ( const void * ) & ( rtDW . l1c0vzua01 ) , sizeof ( rtDW . l1c0vzua01 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 28 , ( const void * ) & ( rtDW . j1zvgotszs ) , sizeof ( rtDW . j1zvgotszs ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 29 , ( const void * ) & ( rtDW . oktrhzldpx ) , sizeof ( rtDW . oktrhzldpx ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 30 , ( const void * ) & ( rtDW . aqm5jnhwyz ) , sizeof ( rtDW . aqm5jnhwyz ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 31 , ( const void * ) & ( rtDW . lndskdfmom ) , sizeof ( rtDW . lndskdfmom ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 32 , ( const void * ) & ( rtDW . iur0xot0u0 ) , sizeof ( rtDW . iur0xot0u0 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 33 , ( const void * ) & ( rtDW . hwgvqn3aty ) , sizeof ( rtDW . hwgvqn3aty ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 34 , ( const void * ) & ( rtDW . hgyea5eklz ) , sizeof ( rtDW . hgyea5eklz ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 35 , ( const void * ) & ( rtDW . ic10kvv3vn ) , sizeof ( rtDW . ic10kvv3vn ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 36 , ( const void * ) & ( rtDW . gsaeaqfztj ) , sizeof ( rtDW . gsaeaqfztj ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 37 , ( const void * ) & ( rtDW . pswit010me ) , sizeof ( rtDW . pswit010me ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 38 , ( const void * ) & ( rtDW . bfxht5ivew ) , sizeof ( rtDW . bfxht5ivew ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 39 , ( const void * ) & ( rtDW . dzo1rnylqc ) , sizeof ( rtDW . dzo1rnylqc ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 40 , ( const void * ) & ( rtDW . nnoau3gejb ) , sizeof ( rtDW . nnoau3gejb ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 41 , ( const void * ) & ( rtDW . bexc5hutlj ) , sizeof ( rtDW . bexc5hutlj ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 42 , ( const void * ) & ( rtDW . hq42bs4esx ) , sizeof ( rtDW . hq42bs4esx ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 43 , ( const void * ) & ( rtDW . cr5oo1xudj ) , sizeof ( rtDW . cr5oo1xudj ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 44 , ( const void * ) & ( rtDW . akw4wluyho ) , sizeof ( rtDW . akw4wluyho ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 45 , ( const void * ) & ( rtDW . ks031m0ijp ) , sizeof ( rtDW . ks031m0ijp ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 46 , ( const void * ) & ( rtDW . pk4xbzciev ) , sizeof ( rtDW . pk4xbzciev ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 47 , ( const void * ) & ( rtDW . mxc2whhzeq ) , sizeof ( rtDW . mxc2whhzeq ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 48 , ( const void * ) & ( rtDW . f5r30m5mlp ) , sizeof ( rtDW . f5r30m5mlp ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 49 , ( const void * ) & ( rtDW . mre1waafup ) , sizeof ( rtDW . mre1waafup ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 50 , ( const void * ) & ( rtDW . fqcwpuiypl ) , sizeof ( rtDW . fqcwpuiypl ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 51 , ( const void * ) & ( rtDW . ilpdoalijh ) , sizeof ( rtDW . ilpdoalijh ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 52 , ( const void * ) & ( rtDW . gr1pr4ue0h ) , sizeof ( rtDW . gr1pr4ue0h ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 53 , ( const void * ) & ( rtDW . jdajwtteu1 ) , sizeof ( rtDW . jdajwtteu1 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 54 , ( const void * ) & ( rtDW . bsktzayyjw ) , sizeof ( rtDW . bsktzayyjw ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 55 , ( const void * ) & ( rtDW . ndrbsa54bo ) , sizeof ( rtDW . ndrbsa54bo ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 56 , ( const void * ) & ( rtDW . fseioyxtld ) , sizeof ( rtDW . fseioyxtld ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 57 , ( const void * ) & ( rtDW . lamh4epvtt ) , sizeof ( rtDW . lamh4epvtt ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 58 , ( const void * ) & ( rtDW . a5s15vizq1 ) , sizeof ( rtDW . a5s15vizq1 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 59 , ( const void * ) & ( rtDW . lwcgqnzxxh ) , sizeof ( rtDW . lwcgqnzxxh ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 60 , ( const void * ) & ( rtDW . nbymm4zf0e ) , sizeof ( rtDW . nbymm4zf0e ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 61 , ( const void * ) & ( rtDW . akl20qtgvf ) , sizeof ( rtDW . akl20qtgvf ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 62 , ( const void * ) & ( rtDW . cg5p3fc1vb ) , sizeof ( rtDW . cg5p3fc1vb ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 63 , ( const void * ) & ( rtDW . c2zvhsobgq ) , sizeof ( rtDW . c2zvhsobgq ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 64 , ( const void * ) & ( rtDW . ce4ngnm0vz ) , sizeof ( rtDW . ce4ngnm0vz ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 65 , ( const void * ) & ( rtDW . ozkuq5jrkw ) , sizeof ( rtDW . ozkuq5jrkw ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 66 , ( const void * ) & ( rtDW . n52coetlf4 ) , sizeof ( rtDW . n52coetlf4 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 67 , ( const void * ) & ( rtDW . pozaiatm4a ) , sizeof ( rtDW . pozaiatm4a ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 68 , ( const void * ) & ( rtDW . gf4ksr2aha ) , sizeof ( rtDW . gf4ksr2aha ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 69 , ( const void * ) & ( rtDW . fgliutlg4v ) , sizeof ( rtDW . fgliutlg4v ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 70 , ( const void * ) & ( rtDW . gbzgjra1qd ) , sizeof ( rtDW . gbzgjra1qd ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 71 , ( const void * ) & ( rtDW . krmutnbn45 ) , sizeof ( rtDW . krmutnbn45 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 72 , ( const void * ) & ( rtDW . njxj2gqdqb ) , sizeof ( rtDW . njxj2gqdqb ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 73 , ( const void * ) & ( rtDW . kdmfiti23w ) , sizeof ( rtDW . kdmfiti23w ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 74 , ( const void * ) & ( rtDW . phgeenzoik ) , sizeof ( rtDW . phgeenzoik ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 75 , ( const void * ) & ( rtDW . myaevvlju4 ) , sizeof ( rtDW . myaevvlju4 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 76 , ( const void * ) & ( rtDW . m405qgdu1y ) , sizeof ( rtDW . m405qgdu1y ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 77 , ( const void * ) & ( rtDW . nmot3ctkc4 ) , sizeof ( rtDW . nmot3ctkc4 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 78 , ( const void * ) & ( rtDW . hihjm3wgc4 ) , sizeof ( rtDW . hihjm3wgc4 ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 79 , ( const void * ) & ( rtDW . gb30213u1q ) , sizeof ( rtDW . gb30213u1q ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 80 , ( const void * ) & ( rtDW . eamuase24a ) , sizeof ( rtDW . eamuase24a ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 81 , ( const void * ) & ( rtDW . aen5lyyfuu ) , sizeof ( rtDW . aen5lyyfuu ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 82 , ( const void * ) & ( rtDW . eeglzokwfe ) , sizeof ( rtDW . eeglzokwfe ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 83 , ( const void * ) & ( rtDW . ihhztqiixf ) , sizeof ( rtDW . ihhztqiixf ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 84 , ( const void * ) & ( rtDW . fmscqp2pk3 . ajgetwghvc ) , sizeof ( rtDW . fmscqp2pk3 . ajgetwghvc ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 85 , ( const void * ) & ( rtDW . fmscqp2pk3 . mbrn4fhlwd ) , sizeof ( rtDW . fmscqp2pk3 . mbrn4fhlwd ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 86 , ( const void * ) & ( rtDW . nf1oadke3r . ajgetwghvc ) , sizeof ( rtDW . nf1oadke3r . ajgetwghvc ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 87 , ( const void * ) & ( rtDW . nf1oadke3r . mbrn4fhlwd ) , sizeof ( rtDW . nf1oadke3r . mbrn4fhlwd ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 88 , ( const void * ) & ( rtDW . hbgiv4wxgq . cxxrtrw5jz ) , sizeof ( rtDW . hbgiv4wxgq . cxxrtrw5jz ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 89 , ( const void * ) & ( rtDW . hbgiv4wxgq . bhv4aykvhq ) , sizeof ( rtDW . hbgiv4wxgq . bhv4aykvhq ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 90 , ( const void * ) & ( rtDW . ifmn2jhohh . cxxrtrw5jz ) , sizeof ( rtDW . ifmn2jhohh . cxxrtrw5jz ) ) ; mr_boat_cacheDataAsMxArray ( rtdwData , 0 , 91 , ( const void * ) & ( rtDW . ifmn2jhohh . bhv4aykvhq ) , sizeof ( rtDW . ifmn2jhohh . bhv4aykvhq ) ) ; mxSetFieldByNumber ( ssDW , 0 , 1 , rtdwData ) ; } return ssDW ; } void mr_boat_SetDWork ( const mxArray * ssDW ) { ( void ) ssDW ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtB ) , ssDW , 0 , 0 , sizeof ( rtB ) ) ; { const mxArray * rtdwData = mxGetFieldByNumber ( ssDW , 0 , 1 ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . fqyyafssv0 ) , rtdwData , 0 , 0 , sizeof ( rtDW . fqyyafssv0 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . htt1amrvgv ) , rtdwData , 0 , 1 , sizeof ( rtDW . htt1amrvgv ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . bssgbwzn5f ) , rtdwData , 0 , 2 , sizeof ( rtDW . bssgbwzn5f ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . evor0o0u1w ) , rtdwData , 0 , 3 , sizeof ( rtDW . evor0o0u1w ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . jj4ax1istk ) , rtdwData , 0 , 4 , sizeof ( rtDW . jj4ax1istk ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . megpocnlzf ) , rtdwData , 0 , 5 , sizeof ( rtDW . megpocnlzf ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . cq4fy31po1 ) , rtdwData , 0 , 6 , sizeof ( rtDW . cq4fy31po1 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ifeym0p3d4 ) , rtdwData , 0 , 7 , sizeof ( rtDW . ifeym0p3d4 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . doojhifyms ) , rtdwData , 0 , 8 , sizeof ( rtDW . doojhifyms ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ik3uudsjyg ) , rtdwData , 0 , 9 , sizeof ( rtDW . ik3uudsjyg ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . and0otfyv2 ) , rtdwData , 0 , 10 , sizeof ( rtDW . and0otfyv2 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . habwkca01a ) , rtdwData , 0 , 11 , sizeof ( rtDW . habwkca01a ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . k4wpb4vucr ) , rtdwData , 0 , 12 , sizeof ( rtDW . k4wpb4vucr ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . m5zbqevzsx ) , rtdwData , 0 , 13 , sizeof ( rtDW . m5zbqevzsx ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . b5owcqllef ) , rtdwData , 0 , 14 , sizeof ( rtDW . b5owcqllef ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ihfadbhak5 ) , rtdwData , 0 , 15 , sizeof ( rtDW . ihfadbhak5 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . f2qgyziyrt ) , rtdwData , 0 , 16 , sizeof ( rtDW . f2qgyziyrt ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . idc5s0rsfa ) , rtdwData , 0 , 17 , sizeof ( rtDW . idc5s0rsfa ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ev3nsxizqu ) , rtdwData , 0 , 18 , sizeof ( rtDW . ev3nsxizqu ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ks3ujawclj ) , rtdwData , 0 , 19 , sizeof ( rtDW . ks3ujawclj ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . cqweur5z4o ) , rtdwData , 0 , 20 , sizeof ( rtDW . cqweur5z4o ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . oq4y10dztc ) , rtdwData , 0 , 21 , sizeof ( rtDW . oq4y10dztc ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . hxbifjq51u ) , rtdwData , 0 , 22 , sizeof ( rtDW . hxbifjq51u ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . gc5xhbklnl ) , rtdwData , 0 , 23 , sizeof ( rtDW . gc5xhbklnl ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . cxcc0o32ih ) , rtdwData , 0 , 24 , sizeof ( rtDW . cxcc0o32ih ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . k1sbpk4k2l ) , rtdwData , 0 , 25 , sizeof ( rtDW . k1sbpk4k2l ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ewof0menw2 ) , rtdwData , 0 , 26 , sizeof ( rtDW . ewof0menw2 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . l1c0vzua01 ) , rtdwData , 0 , 27 , sizeof ( rtDW . l1c0vzua01 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . j1zvgotszs ) , rtdwData , 0 , 28 , sizeof ( rtDW . j1zvgotszs ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . oktrhzldpx ) , rtdwData , 0 , 29 , sizeof ( rtDW . oktrhzldpx ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . aqm5jnhwyz ) , rtdwData , 0 , 30 , sizeof ( rtDW . aqm5jnhwyz ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . lndskdfmom ) , rtdwData , 0 , 31 , sizeof ( rtDW . lndskdfmom ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . iur0xot0u0 ) , rtdwData , 0 , 32 , sizeof ( rtDW . iur0xot0u0 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . hwgvqn3aty ) , rtdwData , 0 , 33 , sizeof ( rtDW . hwgvqn3aty ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . hgyea5eklz ) , rtdwData , 0 , 34 , sizeof ( rtDW . hgyea5eklz ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ic10kvv3vn ) , rtdwData , 0 , 35 , sizeof ( rtDW . ic10kvv3vn ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . gsaeaqfztj ) , rtdwData , 0 , 36 , sizeof ( rtDW . gsaeaqfztj ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . pswit010me ) , rtdwData , 0 , 37 , sizeof ( rtDW . pswit010me ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . bfxht5ivew ) , rtdwData , 0 , 38 , sizeof ( rtDW . bfxht5ivew ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . dzo1rnylqc ) , rtdwData , 0 , 39 , sizeof ( rtDW . dzo1rnylqc ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . nnoau3gejb ) , rtdwData , 0 , 40 , sizeof ( rtDW . nnoau3gejb ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . bexc5hutlj ) , rtdwData , 0 , 41 , sizeof ( rtDW . bexc5hutlj ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . hq42bs4esx ) , rtdwData , 0 , 42 , sizeof ( rtDW . hq42bs4esx ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . cr5oo1xudj ) , rtdwData , 0 , 43 , sizeof ( rtDW . cr5oo1xudj ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . akw4wluyho ) , rtdwData , 0 , 44 , sizeof ( rtDW . akw4wluyho ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ks031m0ijp ) , rtdwData , 0 , 45 , sizeof ( rtDW . ks031m0ijp ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . pk4xbzciev ) , rtdwData , 0 , 46 , sizeof ( rtDW . pk4xbzciev ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . mxc2whhzeq ) , rtdwData , 0 , 47 , sizeof ( rtDW . mxc2whhzeq ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . f5r30m5mlp ) , rtdwData , 0 , 48 , sizeof ( rtDW . f5r30m5mlp ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . mre1waafup ) , rtdwData , 0 , 49 , sizeof ( rtDW . mre1waafup ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . fqcwpuiypl ) , rtdwData , 0 , 50 , sizeof ( rtDW . fqcwpuiypl ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ilpdoalijh ) , rtdwData , 0 , 51 , sizeof ( rtDW . ilpdoalijh ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . gr1pr4ue0h ) , rtdwData , 0 , 52 , sizeof ( rtDW . gr1pr4ue0h ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . jdajwtteu1 ) , rtdwData , 0 , 53 , sizeof ( rtDW . jdajwtteu1 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . bsktzayyjw ) , rtdwData , 0 , 54 , sizeof ( rtDW . bsktzayyjw ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ndrbsa54bo ) , rtdwData , 0 , 55 , sizeof ( rtDW . ndrbsa54bo ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . fseioyxtld ) , rtdwData , 0 , 56 , sizeof ( rtDW . fseioyxtld ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . lamh4epvtt ) , rtdwData , 0 , 57 , sizeof ( rtDW . lamh4epvtt ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . a5s15vizq1 ) , rtdwData , 0 , 58 , sizeof ( rtDW . a5s15vizq1 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . lwcgqnzxxh ) , rtdwData , 0 , 59 , sizeof ( rtDW . lwcgqnzxxh ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . nbymm4zf0e ) , rtdwData , 0 , 60 , sizeof ( rtDW . nbymm4zf0e ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . akl20qtgvf ) , rtdwData , 0 , 61 , sizeof ( rtDW . akl20qtgvf ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . cg5p3fc1vb ) , rtdwData , 0 , 62 , sizeof ( rtDW . cg5p3fc1vb ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . c2zvhsobgq ) , rtdwData , 0 , 63 , sizeof ( rtDW . c2zvhsobgq ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ce4ngnm0vz ) , rtdwData , 0 , 64 , sizeof ( rtDW . ce4ngnm0vz ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ozkuq5jrkw ) , rtdwData , 0 , 65 , sizeof ( rtDW . ozkuq5jrkw ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . n52coetlf4 ) , rtdwData , 0 , 66 , sizeof ( rtDW . n52coetlf4 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . pozaiatm4a ) , rtdwData , 0 , 67 , sizeof ( rtDW . pozaiatm4a ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . gf4ksr2aha ) , rtdwData , 0 , 68 , sizeof ( rtDW . gf4ksr2aha ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . fgliutlg4v ) , rtdwData , 0 , 69 , sizeof ( rtDW . fgliutlg4v ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . gbzgjra1qd ) , rtdwData , 0 , 70 , sizeof ( rtDW . gbzgjra1qd ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . krmutnbn45 ) , rtdwData , 0 , 71 , sizeof ( rtDW . krmutnbn45 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . njxj2gqdqb ) , rtdwData , 0 , 72 , sizeof ( rtDW . njxj2gqdqb ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . kdmfiti23w ) , rtdwData , 0 , 73 , sizeof ( rtDW . kdmfiti23w ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . phgeenzoik ) , rtdwData , 0 , 74 , sizeof ( rtDW . phgeenzoik ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . myaevvlju4 ) , rtdwData , 0 , 75 , sizeof ( rtDW . myaevvlju4 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . m405qgdu1y ) , rtdwData , 0 , 76 , sizeof ( rtDW . m405qgdu1y ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . nmot3ctkc4 ) , rtdwData , 0 , 77 , sizeof ( rtDW . nmot3ctkc4 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . hihjm3wgc4 ) , rtdwData , 0 , 78 , sizeof ( rtDW . hihjm3wgc4 ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . gb30213u1q ) , rtdwData , 0 , 79 , sizeof ( rtDW . gb30213u1q ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . eamuase24a ) , rtdwData , 0 , 80 , sizeof ( rtDW . eamuase24a ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . aen5lyyfuu ) , rtdwData , 0 , 81 , sizeof ( rtDW . aen5lyyfuu ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . eeglzokwfe ) , rtdwData , 0 , 82 , sizeof ( rtDW . eeglzokwfe ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ihhztqiixf ) , rtdwData , 0 , 83 , sizeof ( rtDW . ihhztqiixf ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . fmscqp2pk3 . ajgetwghvc ) , rtdwData , 0 , 84 , sizeof ( rtDW . fmscqp2pk3 . ajgetwghvc ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . fmscqp2pk3 . mbrn4fhlwd ) , rtdwData , 0 , 85 , sizeof ( rtDW . fmscqp2pk3 . mbrn4fhlwd ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . nf1oadke3r . ajgetwghvc ) , rtdwData , 0 , 86 , sizeof ( rtDW . nf1oadke3r . ajgetwghvc ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . nf1oadke3r . mbrn4fhlwd ) , rtdwData , 0 , 87 , sizeof ( rtDW . nf1oadke3r . mbrn4fhlwd ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . hbgiv4wxgq . cxxrtrw5jz ) , rtdwData , 0 , 88 , sizeof ( rtDW . hbgiv4wxgq . cxxrtrw5jz ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . hbgiv4wxgq . bhv4aykvhq ) , rtdwData , 0 , 89 , sizeof ( rtDW . hbgiv4wxgq . bhv4aykvhq ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ifmn2jhohh . cxxrtrw5jz ) , rtdwData , 0 , 90 , sizeof ( rtDW . ifmn2jhohh . cxxrtrw5jz ) ) ; mr_boat_restoreDataFromMxArray ( ( void * ) & ( rtDW . ifmn2jhohh . bhv4aykvhq ) , rtdwData , 0 , 91 , sizeof ( rtDW . ifmn2jhohh . bhv4aykvhq ) ) ; } } mxArray * mr_boat_GetSimStateDisallowedBlocks ( ) { mxArray * data = mxCreateCellMatrix ( 10 , 3 ) ; mwIndex subs [ 2 ] , offset ; { static const char_T * blockType [ 10 ] = { "Scope" , "Scope" , "Scope" , "Scope" , "Scope" , "Scope" , "SimscapeExecutionBlock" , "SimscapeExecutionBlock" , "SimscapeExecutionBlock" , "SimscapeExecutionBlock" , } ; static const char_T * blockPath [ 10 ] = { "boat/Scope" , "boat/Scope1" , "boat/Scope10" , "boat/Scope2" , "boat/Scope3" , "boat/Scope4" , "boat/Solver Configuration1/EVAL_KEY/STATE_1" , "boat/Solver Configuration1/EVAL_KEY/OUTPUT_1_0" , "boat/Solver Configuration/EVAL_KEY/STATE_1" , "boat/Solver Configuration/EVAL_KEY/OUTPUT_1_0" , } ; static const int reason [ 10 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , } ; for ( subs [ 0 ] = 0 ; subs [ 0 ] < 10 ; ++ ( subs [ 0 ] ) ) { subs [ 1 ] = 0 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockType [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 1 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockPath [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 2 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateDoubleScalar ( ( real_T ) reason [ subs [ 0 ] ] ) ) ; } } return data ; } void MdlInitializeSizes ( void ) { ssSetNumContStates ( rtS , 22 ) ; ssSetNumPeriodicContStates ( rtS , 0 ) ; ssSetNumY ( rtS , 0 ) ; ssSetNumU ( rtS , 0 ) ; ssSetDirectFeedThrough ( rtS , 0 ) ; ssSetNumSampleTimes ( rtS , 6 ) ; ssSetNumBlocks ( rtS , 191 ) ; ssSetNumBlockIO ( rtS , 102 ) ; ssSetNumBlockParams ( rtS , 70 ) ; } void MdlInitializeSampleTimes ( void ) { ssSetSampleTime ( rtS , 0 , 0.0 ) ; ssSetSampleTime ( rtS , 1 , 0.0 ) ; ssSetSampleTime ( rtS , 2 , 0.1 ) ; ssSetSampleTime ( rtS , 3 , - 2.0 ) ; ssSetSampleTime ( rtS , 4 , - 2.0 ) ; ssSetSampleTime ( rtS , 5 , - 2.0 ) ; ssSetOffsetTime ( rtS , 0 , 0.0 ) ; ssSetOffsetTime ( rtS , 1 , 1.0 ) ; ssSetOffsetTime ( rtS , 2 , 0.0 ) ; ssSetOffsetTime ( rtS , 3 , 0.0 ) ; ssSetOffsetTime ( rtS , 4 , 1.0 ) ; ssSetOffsetTime ( rtS , 5 , 2.0 ) ; } void raccel_set_checksum ( ) { ssSetChecksumVal ( rtS , 0 , 2663002389U ) ; ssSetChecksumVal ( rtS , 1 , 3895314875U ) ; ssSetChecksumVal ( rtS , 2 , 3046818960U ) ; ssSetChecksumVal ( rtS , 3 , 1304285842U ) ; }
#if defined(_MSC_VER)
#pragma optimize( "", off )
#endif
SimStruct * raccel_register_model ( ssExecutionInfo * executionInfo ) {
static struct _ssMdlInfo mdlInfo ; static struct _ssBlkInfo2 blkInfo2 ;
static struct _ssBlkInfoSLSize blkInfoSLSize ; rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; executionInfo -> gblObjects_ . numToFiles = 0 ; executionInfo -> gblObjects_ . numFrFiles = 0 ; executionInfo -> gblObjects_ . numFrWksBlocks = 0 ; executionInfo -> gblObjects_ . numModelInputs = 0 ; executionInfo -> gblObjects_ . numRootInportBlks = 0 ; executionInfo -> gblObjects_ . inportDataTypeIdx = NULL ; executionInfo -> gblObjects_ . inportDims = NULL ; executionInfo -> gblObjects_ . inportComplex = NULL ; executionInfo -> gblObjects_ . inportInterpoFlag = NULL ; executionInfo -> gblObjects_ . inportContinuous = NULL ; ( void ) memset ( ( char_T * ) rtS , 0 , sizeof ( SimStruct ) ) ; ( void ) memset ( ( char_T * ) & mdlInfo , 0 , sizeof ( struct _ssMdlInfo ) ) ; ( void ) memset ( ( char_T * ) & blkInfo2 , 0 , sizeof ( struct _ssBlkInfo2 ) ) ; ( void ) memset ( ( char_T * ) & blkInfoSLSize , 0 , sizeof ( struct _ssBlkInfoSLSize ) ) ; ssSetBlkInfo2Ptr ( rtS , & blkInfo2 ) ; ssSetBlkInfoSLSizePtr ( rtS , & blkInfoSLSize ) ; ssSetMdlInfoPtr ( rtS , & mdlInfo ) ; ssSetExecutionInfo ( rtS , executionInfo ) ; slsaAllocOPModelData ( rtS ) ; { static time_T mdlPeriod [ NSAMPLE_TIMES ] ; static time_T mdlOffset [ NSAMPLE_TIMES ] ; static time_T mdlTaskTimes [ NSAMPLE_TIMES ] ; static int_T mdlTsMap [ NSAMPLE_TIMES ] ; static int_T mdlSampleHits [ NSAMPLE_TIMES ] ; static boolean_T mdlTNextWasAdjustedPtr [ NSAMPLE_TIMES ] ; static int_T mdlPerTaskSampleHits [ NSAMPLE_TIMES * NSAMPLE_TIMES ] ; static time_T mdlTimeOfNextSampleHit [ NSAMPLE_TIMES ] ; { int_T i ; for ( i = 0 ; i < NSAMPLE_TIMES ; i ++ ) { mdlPeriod [ i ] = 0.0 ; mdlOffset [ i ] = 0.0 ; mdlTaskTimes [ i ] = 0.0 ; mdlTsMap [ i ] = i ; mdlSampleHits [ i ] = 1 ; } } ssSetSampleTimePtr ( rtS , & mdlPeriod [ 0 ] ) ; ssSetOffsetTimePtr ( rtS , & mdlOffset [ 0 ] ) ; ssSetSampleTimeTaskIDPtr ( rtS , & mdlTsMap [ 0 ] ) ; ssSetTPtr ( rtS , & mdlTaskTimes [ 0 ] ) ; ssSetSampleHitPtr ( rtS , & mdlSampleHits [ 0 ] ) ; ssSetTNextWasAdjustedPtr ( rtS , & mdlTNextWasAdjustedPtr [ 0 ] ) ; ssSetPerTaskSampleHitsPtr ( rtS , & mdlPerTaskSampleHits [ 0 ] ) ; ssSetTimeOfNextSampleHitPtr ( rtS , & mdlTimeOfNextSampleHit [ 0 ] ) ; } ssSetSolverMode ( rtS , SOLVER_MODE_SINGLETASKING ) ; { ssSetBlockIO ( rtS , ( ( void * ) & rtB ) ) ; ( void ) memset ( ( ( void * ) & rtB ) , 0 , sizeof ( B ) ) ; } { real_T * x = ( real_T * ) & rtX ; ssSetContStates ( rtS , x ) ; ( void ) memset ( ( void * ) x , 0 , sizeof ( X ) ) ; } { void * dwork = ( void * ) & rtDW ; ssSetRootDWork ( rtS , dwork ) ; ( void ) memset ( dwork , 0 , sizeof ( DW ) ) ; } { static DataTypeTransInfo dtInfo ; ( void ) memset ( ( char_T * ) & dtInfo , 0 , sizeof ( dtInfo ) ) ; ssSetModelMappingInfo ( rtS , & dtInfo ) ; dtInfo . numDataTypes = 23 ; dtInfo . dataTypeSizes = & rtDataTypeSizes [ 0 ] ; dtInfo . dataTypeNames = & rtDataTypeNames [ 0 ] ; dtInfo . BTransTable = & rtBTransTable ; dtInfo . PTransTable = & rtPTransTable ; dtInfo . dataTypeInfoTable = rtDataTypeInfoTable ; } boat_InitializeDataMapInfo ( ) ; ssSetIsRapidAcceleratorActive ( rtS , true ) ; ssSetRootSS ( rtS , rtS ) ; ssSetVersion ( rtS , SIMSTRUCT_VERSION_LEVEL2 ) ; ssSetModelName ( rtS , "boat" ) ; ssSetPath ( rtS , "boat" ) ; ssSetTStart ( rtS , 0.0 ) ; ssSetTFinal ( rtS , 100.0 ) ; { static RTWLogInfo rt_DataLoggingInfo ; rt_DataLoggingInfo . loggingInterval = ( NULL ) ; ssSetRTWLogInfo ( rtS , & rt_DataLoggingInfo ) ; } { { static int_T rt_LoggedStateWidths [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 } ; static int_T rt_LoggedStateNumDimensions [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; static int_T rt_LoggedStateDimensions [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 } ; static boolean_T rt_LoggedStateIsVarDims [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static BuiltInDTypeId rt_LoggedStateDataTypeIds [ ] = { SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE } ; static int_T rt_LoggedStateComplexSignals [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static RTWPreprocessingFcnPtr rt_LoggingStatePreprocessingFcnPtrs [ ] = { ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) } ; static const char_T * rt_LoggedStateLabels [ ] = { "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "Discrete" , "Discrete" , "Discrete" } ; static const char_T * rt_LoggedStateBlockNames [ ] = { "boat/Integrator1" , "boat/Integrator3" , "boat/Integrator5" , "boat/PID Controller/Integrator/Continuous/Integrator" , "boat/PID Controller/Filter/Cont. Filter/Filter" , "boat/PID Controller1/Integrator/Continuous/Integrator" , "boat/PID Controller1/Filter/Cont. Filter/Filter" , "boat/PID Controller2/Integrator/Continuous/Integrator" , "boat/PID Controller2/Filter/Cont. Filter/Filter" , "boat/DC Motor1" , "boat/DC Motor1" , "boat/Ideal Rotational Motion Sensor1" , "boat/DC Motor" , "boat/DC Motor" , "boat/Ideal Rotational Motion Sensor" , "boat/DC Motor2" , "boat/DC Motor2" , "boat/Ideal Rotational Motion Sensor2" , "boat/Integrator4" , "boat/Integrator" , "boat/Integrator2" , "boat/Integrator6" , "boat/Solver\nConfiguration/EVAL_KEY/INPUT_1_1_1" , "boat/Solver\nConfiguration1/EVAL_KEY/INPUT_1_1_1" , "boat/Solver\nConfiguration2/EVAL_KEY/INPUT_1_1_1" } ; static const char_T * rt_LoggedStateNames [ ] = { "" , "" , "" , "" , "" , "" , "" , "" , "" , "boat.DC_Motor1.w" , "boat.DC_Motor1.i_L" , "boat.Ideal_Rotational_Motion_Sensor1.phi" , "boat.DC_Motor.i_L" , "boat.DC_Motor.w" , "boat.Ideal_Rotational_Motion_Sensor.phi" , "boat.DC_Motor2.i_L" , "boat.DC_Motor2.w" , "boat.Ideal_Rotational_Motion_Sensor2.phi" , "" , "" , "" , "" , "Discrete" , "Discrete" , "Discrete" } ; static boolean_T rt_LoggedStateCrossMdlRef [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert [ ] = { { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } } ; static int_T rt_LoggedStateIdxList [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 0 , 1 , 2 } ; static RTWLogSignalInfo rt_LoggedStateSignalInfo = { 25 , rt_LoggedStateWidths , rt_LoggedStateNumDimensions , rt_LoggedStateDimensions , rt_LoggedStateIsVarDims , ( NULL ) , ( NULL ) , rt_LoggedStateDataTypeIds , rt_LoggedStateComplexSignals , ( NULL ) , rt_LoggingStatePreprocessingFcnPtrs , { rt_LoggedStateLabels } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedStateBlockNames } , { rt_LoggedStateNames } , rt_LoggedStateCrossMdlRef , rt_RTWLogDataTypeConvert , rt_LoggedStateIdxList } ; static void * rt_LoggedStateSignalPtrs [ 25 ] ; rtliSetLogXSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( LogSignalPtrsType ) rt_LoggedStateSignalPtrs ) ; rtliSetLogXSignalInfo ( ssGetRTWLogInfo ( rtS ) , & rt_LoggedStateSignalInfo ) ; rt_LoggedStateSignalPtrs [ 0 ] = ( void * ) & rtX . f2d4l4jl4s ; rt_LoggedStateSignalPtrs [ 1 ] = ( void * ) & rtX . eqm01ekw05 ; rt_LoggedStateSignalPtrs [ 2 ] = ( void * ) & rtX . llcy0vep2l ; rt_LoggedStateSignalPtrs [ 3 ] = ( void * ) & rtX . kv3akytruj ; rt_LoggedStateSignalPtrs [ 4 ] = ( void * ) & rtX . ecyoj2i3gw ; rt_LoggedStateSignalPtrs [ 5 ] = ( void * ) & rtX . g13n4kjtrj ; rt_LoggedStateSignalPtrs [ 6 ] = ( void * ) & rtX . bgucvxka1s ; rt_LoggedStateSignalPtrs [ 7 ] = ( void * ) & rtX . lgrsqc5d1d ; rt_LoggedStateSignalPtrs [ 8 ] = ( void * ) & rtX . fmj0130ch2 ; rt_LoggedStateSignalPtrs [ 9 ] = ( void * ) & rtX . cbt50efduc [ 0 ] ; rt_LoggedStateSignalPtrs [ 10 ] = ( void * ) & rtX . cbt50efduc [ 1 ] ; rt_LoggedStateSignalPtrs [ 11 ] = ( void * ) & rtX . cbt50efduc [ 2 ] ; rt_LoggedStateSignalPtrs [ 12 ] = ( void * ) & rtX . fbrr2x2skx [ 0 ] ; rt_LoggedStateSignalPtrs [ 13 ] = ( void * ) & rtX . fbrr2x2skx [ 1 ] ; rt_LoggedStateSignalPtrs [ 14 ] = ( void * ) & rtX . fbrr2x2skx [ 2 ] ; rt_LoggedStateSignalPtrs [ 15 ] = ( void * ) & rtX . mqsayiekhp [ 0 ] ; rt_LoggedStateSignalPtrs [ 16 ] = ( void * ) & rtX . mqsayiekhp [ 1 ] ; rt_LoggedStateSignalPtrs [ 17 ] = ( void * ) & rtX . mqsayiekhp [ 2 ] ; rt_LoggedStateSignalPtrs [ 18 ] = ( void * ) & rtX . de235fb3n0 ; rt_LoggedStateSignalPtrs [ 19 ] = ( void * ) & rtX . fqzv5kmfjl ; rt_LoggedStateSignalPtrs [ 20 ] = ( void * ) & rtX . mofkaqi0xy ; rt_LoggedStateSignalPtrs [ 21 ] = ( void * ) & rtX . ds1lkir2ik ; rt_LoggedStateSignalPtrs [ 22 ] = ( void * ) rtDW . fqyyafssv0 ; rt_LoggedStateSignalPtrs [ 23 ] = ( void * ) rtDW . htt1amrvgv ; rt_LoggedStateSignalPtrs [ 24 ] = ( void * ) rtDW . bssgbwzn5f ; } rtliSetLogT ( ssGetRTWLogInfo ( rtS ) , "tout" ) ; rtliSetLogX ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogXFinal ( ssGetRTWLogInfo ( rtS ) , "xFinal" ) ; rtliSetLogVarNameModifier ( ssGetRTWLogInfo ( rtS ) , "none" ) ; rtliSetLogFormat ( ssGetRTWLogInfo ( rtS ) , 4 ) ; rtliSetLogMaxRows ( ssGetRTWLogInfo ( rtS ) , 0 ) ; rtliSetLogDecimation ( ssGetRTWLogInfo ( rtS ) , 1 ) ; rtliSetLogY ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogYSignalInfo ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; rtliSetLogYSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; } { static struct _ssStatesInfo2 statesInfo2 ; ssSetStatesInfo2 ( rtS , & statesInfo2 ) ; } { static ssPeriodicStatesInfo periodicStatesInfo ; ssSetPeriodicStatesInfo ( rtS , & periodicStatesInfo ) ; } { static ssJacobianPerturbationBounds jacobianPerturbationBounds ; ssSetJacobianPerturbationBounds ( rtS , & jacobianPerturbationBounds ) ; } { static ssSolverInfo slvrInfo ; static boolean_T contStatesDisabled [ 22 ] ; static real_T absTol [ 22 ] = { 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 } ; static uint8_T absTolControl [ 22 ] = { 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U , 0U } ; static real_T contStateJacPerturbBoundMinVec [ 22 ] ; static real_T contStateJacPerturbBoundMaxVec [ 22 ] ; static uint8_T zcAttributes [ 13 ] = { ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) } ; static real_T outputTimes [ 38 ] = { 0.0 , 2.702702703 , 5.405405405 , 8.108108108 , 10.81081081 , 13.51351351 , 16.21621622 , 18.91891892 , 21.62162162 , 24.32432432 , 27.02702703 , 29.72972973 , 32.43243243 , 35.13513514 , 37.83783784 , 40.54054054 , 43.24324324 , 45.94594595 , 48.64864865 , 51.35135135 , 54.05405405 , 56.75675676 , 59.45945946 , 62.16216216 , 64.86486486 , 67.56756757 , 70.27027027 , 72.97297297 , 75.67567568 , 78.37837838 , 81.08108108 , 83.78378378 , 86.48648649 , 89.18918919 , 91.89189189 , 94.59459459 , 97.2972973 , 100.0 } ; static ssNonContDerivSigInfo nonContDerivSigInfo [ 6 ] = { { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . mtfmpp51ar ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . prqpzdtaxn ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . cyby0gnkup ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . i2c0qloibe ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . ddyt10yfii ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . h5spww2eug ) , ( NULL ) } } ; { int i ; for ( i = 0 ; i < 22 ; ++ i ) { contStateJacPerturbBoundMinVec [ i ] = 0 ; contStateJacPerturbBoundMaxVec [ i ] = rtGetInf ( ) ; } } ssSetSolverRelTol ( rtS , 0.001 ) ; ssSetStepSize ( rtS , 0.0 ) ; ssSetMinStepSize ( rtS , 0.0 ) ; ssSetMaxNumMinSteps ( rtS , - 1 ) ; ssSetMinStepViolatedError ( rtS , 0 ) ; ssSetMaxStepSize ( rtS , 0.1 ) ; ssSetSolverMaxOrder ( rtS , - 1 ) ; ssSetSolverRefineFactor ( rtS , 1 ) ; ssSetOutputTimes ( rtS , outputTimes ) ; ssSetNumOutputTimes ( rtS , 38 ) ; ssSetOutputTimesOnly ( rtS , 0 ) ; ssSetOutputTimesIndex ( rtS , 0 ) ; ssSetZCCacheNeedsReset ( rtS , 0 ) ; ssSetDerivCacheNeedsReset ( rtS , 0 ) ; ssSetNumNonContDerivSigInfos ( rtS , 6 ) ; ssSetNonContDerivSigInfos ( rtS , nonContDerivSigInfo ) ; ssSetSolverInfo ( rtS , & slvrInfo ) ; ssSetSolverName ( rtS , "VariableStepAuto" ) ; ssSetVariableStepSolver ( rtS , 1 ) ; ssSetSolverConsistencyChecking ( rtS , 0 ) ; ssSetSolverAdaptiveZcDetection ( rtS , 0 ) ; ssSetSolverRobustResetMethod ( rtS , 0 ) ; ssSetAbsTolVector ( rtS , absTol ) ; ssSetAbsTolControlVector ( rtS , absTolControl ) ; ssSetSolverAbsTol_Obsolete ( rtS , absTol ) ; ssSetSolverAbsTolControl_Obsolete ( rtS , absTolControl ) ; ssSetJacobianPerturbationBoundsMinVec ( rtS , contStateJacPerturbBoundMinVec ) ; ssSetJacobianPerturbationBoundsMaxVec ( rtS , contStateJacPerturbBoundMaxVec ) ; ssSetSolverStateProjection ( rtS , 0 ) ; ssSetSolverMassMatrixType ( rtS , ( ssMatrixType ) 0 ) ; ssSetSolverMassMatrixNzMax ( rtS , 0 ) ; ssSetModelOutputs ( rtS , MdlOutputs ) ; ssSetModelUpdate ( rtS , MdlUpdate ) ; ssSetModelDerivatives ( rtS , MdlDerivatives ) ; ssSetSolverZcSignalAttrib ( rtS , zcAttributes ) ; ssSetSolverNumZcSignals ( rtS , 13 ) ; ssSetModelZeroCrossings ( rtS , MdlZeroCrossings ) ; ssSetSolverConsecutiveZCsStepRelTol ( rtS , 2.8421709430404007E-13 ) ; ssSetSolverMaxConsecutiveZCs ( rtS , 1000 ) ; ssSetSolverConsecutiveZCsError ( rtS , 2 ) ; ssSetSolverMaskedZcDiagnostic ( rtS , 1 ) ; ssSetSolverIgnoredZcDiagnostic ( rtS , 1 ) ; ssSetSolverMaxConsecutiveMinStep ( rtS , 1 ) ; ssSetSolverShapePreserveControl ( rtS , 2 ) ; ssSetTNextTid ( rtS , INT_MIN ) ; ssSetTNext ( rtS , rtMinusInf ) ; ssSetSolverNeedsReset ( rtS ) ; ssSetNumNonsampledZCs ( rtS , 13 ) ; ssSetContStateDisabled ( rtS , contStatesDisabled ) ; ssSetSolverMaxConsecutiveMinStep ( rtS , 1 ) ; } ssSetChecksumVal ( rtS , 0 , 2663002389U ) ; ssSetChecksumVal ( rtS , 1 , 3895314875U ) ; ssSetChecksumVal ( rtS , 2 , 3046818960U ) ; ssSetChecksumVal ( rtS , 3 , 1304285842U ) ; { static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE ; static RTWExtModeInfo rt_ExtModeInfo ; static const sysRanDType * systemRan [ 6 ] ; gblRTWExtModeInfo = & rt_ExtModeInfo ; ssSetRTWExtModeInfo ( rtS , & rt_ExtModeInfo ) ; rteiSetSubSystemActiveVectorAddresses ( & rt_ExtModeInfo , systemRan ) ; systemRan [ 0 ] = & rtAlwaysEnabled ; systemRan [ 1 ] = & rtAlwaysEnabled ; systemRan [ 2 ] = & rtAlwaysEnabled ; systemRan [ 3 ] = & rtAlwaysEnabled ; systemRan [ 4 ] = & rtAlwaysEnabled ; systemRan [ 5 ] = & rtAlwaysEnabled ; rteiSetModelMappingInfoPtr ( ssGetRTWExtModeInfo ( rtS ) , & ssGetModelMappingInfo ( rtS ) ) ; rteiSetChecksumsPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetChecksums ( rtS ) ) ; rteiSetTPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetTPtr ( rtS ) ) ; } slsaDisallowedBlocksForSimTargetOP ( rtS , mr_boat_GetSimStateDisallowedBlocks ) ; slsaGetWorkFcnForSimTargetOP ( rtS , mr_boat_GetDWork ) ; slsaSetWorkFcnForSimTargetOP ( rtS , mr_boat_SetDWork ) ; rt_RapidReadMatFileAndUpdateParams ( rtS ) ; if ( ssGetErrorStatus ( rtS ) ) { return rtS ; } executionInfo -> simulationOptions_ . stateSaveName_ = rtliGetLogX ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . finalStateName_ = rtliGetLogXFinal ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . outputSaveName_ = rtliGetLogY ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . inputTimeTolerance_ = 0.0 ; return rtS ; }
#if defined(_MSC_VER)
#pragma optimize( "", on )
#endif
void MdlOutputsParameterSampleTime ( int_T tid ) { MdlOutputsTID6 ( tid ) ; }
